Instruction Prompts for Final Intro to Programming ii project:




________________




Week 7


4.103 Case study 3: data visualisation


Tasks
Download the data vis project template from the link below of this page and look over the code, starting with stekch.js to get an overview of how the programme works. Try running the code.


All visualisations are stored in the gallery global variable. This variable can be used for debugging in the console to access properties and methods defined within each visualisation.
The lines you need to complete in this case study are marked ???.
Tech diversity: gender
  



Complete the visualisation defined in tech-diversity-gender.js to create a stacked bar chart by adding the proportion of men employed at each company.
1. Look up the documentation for Table.
2. Look at the raw data: ./data/tech-diversity/gender-2018.csv. Use a spreadsheet program or text editor, and make sure you understand the data format (this first line is special). This data will be automatically loaded and stored in the data property (see the preload() method).
3. In the for loop in the draw() method extract the relevant data from each table row and store it in the company object. Hint: Look up the getString() and getNum() table methods, and use the appropriate method to ensure the data is parsed correctly.
4. Check that the bars representing the proportion of female employees is correctly drawn on the plot.
5. Look at how the rectangle representing the proportion of female employees is defined. Draw a rectangle representing the male proportion using the parameters and methods defined in this object. The ratio of female:male staff at Indiegogo is 50:50. Make sure that this is correctly visualised on the plot.


Pay gap 1997–2017
  

Complete the visualisation defined in pay-gap-1997-2017.js to create a line graph representing the pay gap between female and male employees over time.
1. Look at the raw data: ./data/pay-gap/all-employees-hourly-pay-by-gender-1997-2017.csv.
2. In the for loop in the draw() method, extract the relevant data from each table row and store it in the current object.
3. Complete the mapPayGapToHeight() method. Look at how mapYearToWidth() works. Check that the y-axis tick labels are drawn correctly.
4. Complete the line() function in the draw() method to plot the pay gap over time. You will need to use both mapYearToWidth() and mapPayGapToHeight() methods.
Climate change
  

Complete the visualisation defined in climate-change.js to create a line graph with gradient fill background representing the change in the Earth’s surface temperature.
1. Using the mapTemperatureToColour() method, set the fill() in the draw() method. You need to pass the current temperature to this method to get the correct colour.
2. Complete the rect() function below the fill() to create a gradient effect background (rectangles spaced evenly across the x-axis – one rectangle per year). All of the values you need are already accessible within this visualisation object – you need to find them! Hint: Look at the mapYearToWidth() method, the layout object, and the segmentWidth variable.
Tech diversity: Race
  





Complete the visualisation defined in tech-diversity-race.js to create a pie chart to represent the racial diversity of prominent tech companies.
1. Look at the raw data: ./data/tech-diversity/race-2018.csv.
2. Create a select DOM element using p5.dom.js (see createSelect) and populate the options programmatically using the company names obtained from the columns of this.data. Hint: you need to write a for loop.
3. Change the hard-coded company name to instead get the value from the select.
4. Test that when selecting a company name from the list the correct data is visualised on the canvas and the correct title is generated.
Pay gap by job 2017
  





Complete the visualisation defined in pay-gap-by-job-2017.js to create a scatter plot representing the difference in pay for men and women across different jobs.In the draw() method complete the for loop that draws all of the data points on the canvas as ellipses with the following properties.
Hint: You will need to use map().




________________




Week 7
4.201 Introducing P5 data


We are going to introduce you to the final case study
in this topic, a Toolkit of Data Visualizations. To construct this application, we will need to show you an additional object
provided by p5.js. There is no new library
to import this time. The table object is part
of the main pm library. Before we get into
using the table object, let's start by
getting a handle on importing and using data. When we talk about data, we normally think about
it as one of two types; quantitative data and
qualitative data. Qualitative data refers to
forms such as text, images, and interview recordings,
where we can't distill all its meaning into figures for performing mathematical
operations on. We normally choose to
collect and analyze qualitative information when we want to capture something
innately human, something not distillable
into numbers. Quantitative data on the
other hand is data that we can store numbers,
scales, and categories. This is the focus
of this case study. We can store and manipulate a variety of different forms of quantitative data that mirror the variable types we
have in JavaScript. We can utilize numbers, both integer and floating point, strings, and categorizable data where we can arrange
items into groups. If you have the experience with relational style databases, this should be instantly
familiar as with the concepts of organizing
data as a table. By organizing data into a table, we give it structure. Here is some simple data about
fruits in a supermarket. You can see that there are a
number of different types of data being used here:
fruit is a string, type is a category, and then several different
integer values for price, calories, and popularity. Notice the popularity
is a scale., they add order to the data. You will see this frequently
in data collections. Let's look for a moment at
how the data is organized. Each row of the table represents a particular
fruit: apples, pears, bananas, and so on. Each of these rows
is a data point. The columns are referred
to as variables. Just like how we use
the term in JavaScript. P5 provides us with the table object for accessing and manipulating
tabulated data, such as the example in
the previous slides. Mostly, when you use
the table object, we want to load in
external data from a file. We do this with a CSV file, which is short for
comma separated values. I'll show you an example of one of these in the next video. If you haven't used a CSV before, it's just like a very
stripped down spreadsheet that just stores the
data and no formatting. It's one of the most useful
file formats you will come across when studying
computer science. When data has been loaded in, the resulting table
object has methods for accessing the rows and
columns of the table. Here is an example of using
the load table command. We must put in
preload to make sure our data is ready for
use when we need it. If we include the
header argument, we are telling p5 that
the first line of our CSV has the labels
of each column. Now our data is loaded, p5.js provides a
variety of methods for accessing the rows
and columns in the table. Let's start by
looking at the rows. On this graphic,
there is a range of methods you can use
to access raw data. We can get a specific
row by index, like an array, this
is zero indexed. So the first row of
the table is Row 0. We can also search for a particular value in
a particular column, specifying the value
we are looking for and the heading of the row. If p5 can find the result, it returns the first row, the first data point with that value for the
specified column. We can also set and
remove rows of data. Finally, we can also
access data by column. If we want all the values
for a particular variable, say the calorie column
from our fruit table, we can call getColumn
with the name of the heading and p5 will
give us an array of values. Be careful, this will
be an array of strings. So you may need to pause
them into numbers. As always, there are many more methods for
manipulating tabulated data, so make sure you spend some time looking at
the documentation. In the next video, we will look at some real
code with a data table, and understand more
about the CSV format.


________________


Week 7 - 4.202 Accessing external data


We're going to take a look at loading
data into our sketches in practice now. Using the P5 table object and we're
also going to spend a little bit of time thinking about CSV files and
how they're constructed. So I've got a sketch here ready to go. It's got a constructor in it for
a scatter graph. I'm going to talk you through that. I'm not expecting you to write it. I've done all the hard work
with that one for you. We're just going to focus
on loading in some data and trying to get some output from it. So at the moment we've got this
here with just some random data. So I've just generated some random data,
which I'm just displaying and I've got a line of best fit
through the scatter graph. We're going to remove that data and
we're going to change it for something from our our student CSV
file that we've got as an asset here. So if you open up this file in Brackets,
and I'm just going to make this bigger for a second just so it's a bit clearer. You can see we've just got a lot
of text separated by commas. So that's exactly what a CSV file is,
each variable is separated by a comma. So we've got the column here
labeled student number. So the first line is normally
the header row, and so the first line of the first
column name is student number and then the first value for student number is 8 8 4 2 3 and
this is Yvonne Chan's student number. So the data point here being
Yvonne Chan's student record. This data is totally made up. I've just created random names added some
random schools for quizzes and an exam. There's no data breach here. It's all just constructed. I have used a normal distribution
though for getting these numbers. So they look roughly like the kind
of grades that you might get. It's a bit fiddly to look at it here. So if we go over to our finder or your file browser Explorer
if you use Windows, let's just find this this document here. So this is our student CSV file. We don't have to look at it
in this very text view here. We can actually open that
in our spreadsheet program. So if I right click it we can
open with numbers or Excel or if you've got Libre
office you can use that. You can import them into Google Docs, we'll just open it in numbers here
because that's nice and easy to see. There we go.
So here you can see the table laid out nice and clearly columns are even but we've got no formatting actually
stored within this file. Anything that numbers is doing here it's
just doing to make it look clean and easy to read we can add new columns
down here new rows if we want. But we're going to leave this as it is for
now, if you've got data in a spreadsheet and you want to save it as a CSV file in
numbers, you go file export to CSV. In Excel you go save as and
then you select CSV as the file type. So where it's normally dot
xlsx change that to CSV and it will strip out all the formatting and
it will probably give you a warning saying you're going
to lose data if you do this. You're not losing your actual data,
you're losing that formatting and the things that make it look like
a spreadsheet rather than just the raw data and the benefit of the raw
data is when we load it into P5 it knows how to make these into objects,
into variables, into numbers and strings. So let's go back to our sketch and
let's let's load in this data. So my my quick example here
of this scatter diagram. Let's make things back organize
how they were, there we go. So my quick scatter example here we can
just remove when we don't need that. So let's just comment that out and
let's load in some data. So we'll make a global variable. So we'll load it in preload,
and then we'll access it and set up so var studentData. Semicolon and
then let's add in a pre load function. So remember preload operates before setup
is called so if we've got files that we need to load which might take longer
than just the execution of the line. Then we do it in preload and it guarantees
that it's ready for us in setup. So student data equals load table. So that's the P5 command
to load in some data. And we need to give it
the name of the file. So that's students.CSV. And that needs to be in quotes. And we also need to tell it it's
a CSV file because there is another type of data which is tab-separated
data basically the same but except instead of having a comma
between the values you have a tab between the values and
P5 supports both. We also need to tell it that
this data has a header row. So that is going to set the column
names that we have inside our data. If we didn't have that column row. Sorry that header row we can
just leave out header and it will assume that the first
line is the actual data, but it will mean that our our our data is
harder to work with because we won't be able to use the nice names
that we've given things. They'll just be zero indexed columns. So the first one will be 0 next one 1,
2, 3, etc, but now we can use student name,
first name, surname. Okay, so that's that loaded and let's put in here quick console.log so we can see that everything has worked the
way we want it to before we move on and get any further into this, data. So if I open up my inspector. Let's have a look,
we've got an error there and caught out. Yes.
I've forgotten my open and closed parentheses. There we go. Okay. So this is telling us that this console to
out which was our only one in the sketch. So it must be this table. It's a table item and we can see that it's
picked up our header names correctly and we can start to have a look inside this
data and see it, look at it, inspect it. If we look inside the proto object
at the bottom We can see all of those methods that we might want to use
as we manipulate and work with our data. Remember you can find out what each of one
those does inside the P5 documentation. So in fact,
let's very quickly pull that up. So P5.js reference. One thing that catches me out with this. Oops, I will look at the dom reference
there, is I want to go to data. So there's a data section here,
which you can see, it doesn't actually
include the table object. The table object is in I/O because
we're using loadsTable and there's table p5.Table and p5.TableRow. So whenever we call one of
the getRow functions or methods, it's going to return us a row object. Okay, so let's get this back organized. And close out then inspect to that. Okay, so we've now got our data loaded in, let's start before we get
into this this scatter graph. Let's just l get some rows and let's just
put some output, let's see what happens. So, Let's say, studentData.getRow and the one index 0, so we just need to make sure that we
remember to put this into a variable. So, firstStudent =, that's console.log(firstStudent). And we'll lose that one because
we know that works, so, inspect. There you go. So, we ran that before, we lost that, that can quickly. Okay. Okay, so we're now getting out a TableRow. So this represents
the firstStudent in our data whose name if you remember was Yvonne Chan. And we've got various other data
about where she comes from, and a student name and her results. Okay, so that's good. Rather than looking for
a student by which row they're in, that's not going to be too helpful to us. If we say we want to find
students with a particular name. So, let's look for var firstXander. So one of the first names that we
have in our database is Xander. So let's say, let's do studentData.findRow. And let's say we're looking for
a student called Xander, and this will be in the firstName column. Now, I just need to check because we
have to make sure we get these strings right that that is exactly how
firstName is written in our header. Yes, it is. So, just check, make sure that things are
working the way that you expect them to. It's a good idea to have it open the CSV
file open in a spreadsheet as well, so you can quickly look up
what things are called, making sure that you get the column names,
right? So, if we go back to our sketch, let's as well as outputting
the firstStudent, just do console.log(firstXander). There we go. And we've got our firstXander, Xander Jose from Tehran is the firstXander that appears inside our table. So if you want to find the first
instance of someone, use the findRow. If we want to find more than one,
so if we want this to be an array of all
the Xanders in our table, so let's just rename that variable. We want to find rows. So there we go. So there are our Xanders and we've now got several rows that we can access and
get the data from. So if we wanted to, actually quickly,
let's change that back. So we've just got our firstXander and
rather than printing out that whole object,
the JavaScript under the hood stuff. Let's get an actual value from this. So if we say firstXander.getString. And then we say, surname. We should get, just the string Jose. So from the data,
we found a particular row and then we found a particular
variable from that data. So we can start doing quite
a lot of things with this. For our scatter graph, we are going to
want to do something a little different. We are going to want to get all
the scores for a particular assignment. So if we looked back at the studentData,
we've got scores for a quiz, for a project and
an exam and a final mark. So I'm going to pick two of these,
we'll go with quiz and project. And we'll draw them out onto the scatter
graph and see if they correlate. So hopefully, if we've written a good
assignment, we should see that students who do well in one assignment,
they'll do well in the other one. So, we're looking for
a strong correlation there and we can use our scatter graph to show this. So, let's start by just getting
out the data out of the table. So if we do var, let's call it quiz marks first, that's equals studentData, getColumn and
the column that we want to get is quiz. And var projectMarks equals studentData.getColumn, and this will be project. So let's console.log these out. Marks and console.log projectMarks, Oops studentData, so we've made
a little mistake to that There we go. So we now get to arrays of
data that we can use in our scatter graph to show how
students have performed. So let's get rid of our initial
scatterplot stuff here. So I've written this function for
you this constructor, which is going to draw a scatter graph. Now I'm just going to have
a quick run through i,t and then we'll see it in action. You don't need to fully understand this
but it will be great if you used it. Maybe it'll inspire you when you
come to do the data visualization, if that's your chosen project. So the the basic properties
that we have within the scattergraph are just really
it's x and y coordinates. So where are we going to display it
on the canvas, at what width and what height is it going to be? So we get a bit of control about
how it looks in that way, and then there are about three methods here. So we've saved these parameters
as properties of the function. So we've got an x and a y,
a width and a height. We've then got the first method,
which is set up axis, and this is going to work out how to draw those those
axes that the graph is drawn against. So there's quite a few parameters here. So we're giving it the minimum and
the maximum value for the x axis, the minimum and
the maximum value for the y axis, and then we're placing
on said axis a little text. So this is little labels,
so for our quiz scores,x min is going to be 0, x max will be 100. And let's put ticks, say every every 10%. So we'll have those little
labels on our axis. We're just going to set some
simple drawing properties. So black line,
stroke weight of 1, no fill. And then we want to work out a little
bit of padding so we've got space before we draw the lines of the axis to draw in
those ticks and draw in those labels. So the y padding, which is going to
be where the x axis labels are drawn. This will make sense when you see it and
it's a little bit clearer, that's going to be just off the bottom
of where we want the chart to be. And then we've got to do for the x
text something a lot more complicated. Because we don't know how wide those
are going to be before we write this, this is got to be reasonably generic. This isn't a perfect implementation, there's lots of things
that you could add to it. But we don't know,
the scale might go from 0 to 10, it might go from 10 million to 10 billion. And the number that we put on that y
axis is going to be really quite large. So what I'm doing is working out
which is the widest tick label. So if it's 10 billion that's
going to be really quite long and we'll want to draw our y
axis further into the plot. So once we've done that we can
then go about drawing our axes and drawing are ticks. So I've set up a plot y and
a plot height and also a plot width and a plot x properties, which I've added as well as the x and
the y. So these are the actual location and size of the plot itself. So inside the axis,
where can we put our data? So if I draw out an example of this, so I've already got my scatter here, which is a new scatterplot. We're setting the x and the y coordinates,
the width and the height. Let's add an axis. So, setupAxis is the name
of that method so setupAxis, and
alt brackets there is helping us out. So x min is 0, x max is 100,
so we want to go from 0 to 100 to store all
the possible student marks. Same for the y, and let's make the labels
every 10 pixels on each of them. So if I Save and Run that, there we go. There's our axis, so
you can see here we've got our spacing exactly
right between each tick. And we've used the width
here of 100 being the widest possible label to make sure
that our y axis is the right amount across the page to be
able to see those correctly and them to not be missing
off the edge of the page. I've done nothing really about if
my x axis labels are too big but this is just a simple example. It would also be nice to have some axes
labels too, as well as the tick labels, but it's a nice start. So okay, we've got our accesses,
axes, sorry, ready to go. Let's now try and put some data on here. So I've got two methods for
adding data points. We can add a single data point. So we give it the x value,
the y value, the size and the color. Now this isn't an x and a y coordinate,
this is the actual value of the data. Because we've saved that x min and
that x max, and we've got our plot width and
height, we can do all that for the user or for the person using
this scatter graph constructor. So it's quite nice for
the developer who comes along to use this. They've not got to worry about
mapping data to different coordinates, that's all done within the constructor. And in fact,
you can see that happening here. So point x,
we've got a map function being used, rounding out our particular x value and putting it at the right location within
the screen, within the plot sorry. So I've also got here a slightly
more useful property, or method, sorry,
that adds multiple data points. So as well as just adding one
we can take a couple of arrays. And in fact,
this is just calling with a for loop, all those data
points in the array and adding them onto our plots using
the the single addDataPoint method. Okay, so let's use that now
to add on our quiz marks and our project marks to our axis. So, myScatter, .addsDataPoints, and we've got our x values,
is going to be quiz. And also a quiz marks. And then we've got project marks,
and then we also need to add how big we want to make each ellipse
that's going to represent the data points. About 3 pixels will look quite nice and
small on our on our graph. On our graph, and
let's make these points red. Okay, so let's save and
run that and there you go. So we've now got all those data points and you can see there's
a nice correlation there. It looks like our quiz,
people who scored well on the quiz are also scoring
well on the project as well, which is brilliant for us as educators. Although this is all random data,
so it's not really unexpected. I've just added a few points plus or
minus for each assignment based on what
they got on the previous one. So it's not too surprising, but
it is still quite pleasing. So one more method that I've
got in here that I want to show you down the bottom here,
we've also got a line of best fit. So we can add on a line that
runs through all these points. Now, you may remember this
from high school maths. You're using here the least
squares formula to work this out. We're taking in the x and the y values for the two variables that we've got here, quiz score and project score. And then we're working
out from that a gradient represented by m and
the y intercept represented by b. So you probably remember this
formula that y = mx + b. And that's what we're using
here to create a line and then taking that line and
plotting it onto the graph. So let's add that line of best fit in. So myscatter.lineofbestfit. And we need to give it again quiz marks,
Project marks. And we also need to give it a color. So let's set that to blue. Now if I run this,
nothing will happen just yet. And that's because if you remember and
if we look back at our inspector here, we've ended up with a bunch
of strings not numbers. So when I try and do the maths on this
to work out where to draw this line, it's dealing with strings. So something's not gone quite right here. There's a couple of
ways we could fix this. We could parse each of these data points. So use a couple of for loops,
go through them, make them all numbers. But what might be better is actually
to change to scatterplot constructor. So whenever it gets in we just parsefloat. So if we have a look at this,
line of best fit here are our x value parameter,
y value parameter. Wherever we are accessing one of these,
let's just parse the float first. So I'm just, So we'll just add in these and
that should fix our problem. So if you remember back to intro to
programming one when we talked about data types, and we talked about
how JavaScript handles strings when they might be numbers or
they might not be numbers, it's not sure. When we're saying some
x plus equals a string, it's just adding that string on
to what's already in the data. It's already in some x. So we end up with a very long string
rather than adding up the numbers. Where we've got this multiplication sign
here, it's probably doing it right for us. Because JavaScript says, well,
I can't multiply strings. I don't know how to do that. So you must mean that this is a number, so
I'm going to try and use it as a number. But we'll parsefloat on everything
just because it keeps things neat. Makes it readable. So whoever comes and
looks at this knows that we had a whole bunch of strings,
and we're just making sure, That they are in fact
variables that we can use. And now this is fixed for always. And if someone comes along with
floats that aren't strings, the parsefloat will just give
us back the float anyway. So we can use this continually. I've made a little mistake somewhere. Let's have a quick look and
see where that is. Console, par float line 155. And there we go. There we go, and now we've got our
line of best fit through our data. So in this video,
we've covered quite a lot of ground. We have looked at and
loaded in a data table. We've used the P5 table object to
access that data, to change it around. And then we've also used it to
produce a simple visualization using the scatterplot constructor
that I've provided for you.


________________


Week 7 - 4.204 Data visualisation application: under the hood


Okay. So I've got the data visualization app
open here in brackets. You can see there's
a lot of files, it's a little bit daunting, so let's start by looking at
what is most familiar to us. So looking back at my index.html, we can see there's lot's of other scripts being loaded
that we could look at. This ones, these
visualization files all look pretty specific, so I want to start with
the more general things. So looking here, I'm
just going to start with the first one,
helper functions.js. So if I dive into this file, I can see that there are
a load of functions here, and actually once I start
investigating these functions, so I can see they're
all quite independent, they're not attached to
anything else in the program. So if I look at
what this one does, it basically sums what looks like might be an array of numbers
and returns the title. This one finds the mean
of a load of numbers, and this one here converts an array of strings to numbers. We've also got other ones that draw axis for
our visualization. One thing you might
notice with these one is that they all take something called
layouts as an argument. If we're wondering
what layouts is, we can see its layouts got some properties here like left margin and bottom
margin that they miss. So it's definitely expecting
something specific there, and if we scroll
down to the bottom, and so that's our
helper function file. So if you look here, you can see that we've
got an index.html, so I've got that one open. Let's have a look at what
libraries we're using, and I can see here that
I'm using p5.min.js, so I'm using p5 js. So I think on my drawing I'm going to write that in
the top left-hand corner. P5 js is one dependency, and you can see we're also
using p5 dom as well. Let's get that, p5
dom. Not really. There we go. I might just
color my dependencies as well, we'll just go for gray
right over there, so that would be my
code for dependencies. I can see that there
are lots of extra falls but we still have a sketch.js. So I think that that's
where I'm going to go next. So let's have a look
at the sketch.js, and everything looks
as we might expect. We have a setup function and
we have a draw function. So I'm going to call
that my p5.js app, so we'll put that
little box there. So let's say p5 js app. That p5 js app is going to be interacting with an HTML page, the one that we just
looked at before, so I'll add an extra
box for my HTML. Actually, if I just drop back to the HTML, let's have a look, we can see that there is
some styling going on. There's a style.css file. So if I have a
quick look at that, and you can see there
are some clauses there, so let me add that one. So for the moment, I'm just going to
leave that large there and we'll now go and
have a look at in a bit more detail at what's going
on in the setup function. So the first thing I
can see is that we have some p5 dom code which gets
an element of the ID app. So if I have a look
back at the index.html, can I see some code
that has ID app? Yes, we can see it here, there is a div and its id is app. So I think I'll just make
a little note of that. I'll put the hashtag
app there to show that. If I go back again
to my sketch js, you can see that we
create a canvas, and we set its parent to app. So what we're doing is we're
making a canvas element and then we are putting that
canvas inside of that div. Is there anything else in
terms of interaction there? Not for the moment. So that's fine. What I think I'll just
do to finish this little bit off is I will draw a box around all my stuff that is
to do with HTML and CSS, because it's a separate world, and I'll just do maybe
a little dotted line between my p5 JS app to show that I've got some interaction
going on there between my app and that world
of HTML and CSS. So looking back at my index HTML, I can see all these other
files that are being loaded. So these ones look
quite specific, the main visualization files. So I think what I want
to do is just start with some things that are more
generally used across the app, and I can see that one
of the first scripts that is loaded is
helper functions. So let's have a look
inside that file. If I look here, I can see that there are just functions that
are independent. So this one seems to, if I look at this, it takes in some data and
it makes some of the data, and it also looks
like it's converting, making sure that that
data is actually numbers so that it is
able to be summed. This one is taking
a mean average. But these are all things that are not connected
to anything else, they're isolated functions that can operate independently. So that's good,
that's being loaded. I think what I'm going
to do is draw a box for that here, helper functions. Maybe we should just describe a little bit for our
own reference what they do. So if we look at what these different functions in helper functions actually do, we can see that some of
them are drawing functions. So for example,
this one is drawing some labels on y-axis of graphs, and some of them are
just processing data like the sum function
or the mean function. So I think next to this block I'm going to write
what these things do. So there is data processing, and there is drawing
for this going on. I think I'll put a
little line just to show the connection
between my main app and the fact that it can
use helper functions. The other thing that you'll notice is some of
these functions, if I have a look, so
when you draw axis, this one, uses something
called layout, and we can see that layout is a particular type
of objects there. So this object has a top margin, a bottom margin. What
else can we see? A left margin, a margin size, and I'm not sure, I'm going to have a look here. I can't see layout
defined there yet, we just see it used as an
argument for several functions. But definitely helper
functions needs to know about this
thing called layout. So I'm just going to put
it here for the moment, and we'll find out hopefully
where it is defined later. So I'm looking back at
the sketch.js file, and the next thing I
can see is that we are creating an object
called gallery. Because of this new keyword, I can tell that there is a constructive function
for this thing gallery, but I can't see it here
in my sketch js file. But if I look down
at my list of files, I can see something
called gallery.js, and I bet it's probably there. Now, just to confirm that that's being used by my program, I will have a quick
look and see that it's being loaded in the index.html, and I can see it
there, gallery.js. So let's have a look
inside this file. When I look inside, straight away I can see
that indeed there is a constructive function
called gallery. So what I'm going to do, I think, is because this is
quite a big object here that's being created, I'm going to have a
separate note to draw out the various
things in gallery. So let's do that now. Gallery. Okay so let's have a look. We've got some public
properties here. We've got something
cool selectedVisual. So I'm going to put
that in selectedVisual. We don't have any other
public properties, but we've got some private ones. We've got one now you've
seen this person before. We got one called self which is just a
reference to the object. So I'm not really going to
bother noting that one. But we do have this one
that looks important, and that's called visuals. So I'm going to draw books for my object, and in the top half we
have the public area, and in the bottom half we
have the private area, let's make this a bit
neater [inaudible] really a bit messy there. So we've got our properties done. Now let's have a look and see what happens in terms of methods. Well, I can see that I've got a public method called addVisual, and then I have
some private ones, one called selectVisual and
findVisIndex menu item, in fact, it's quite a few. So let's list these
down in my object. So we've got addVisual
in the public area, and then in the private
parts we've got selectVisual and find this index and we've got menu item selected. So what I'll do is just to
color-code this so that I can tell quickly
which is which. I'm going to put all
the properties in blue, so there's one selectedVisual
and Visuals here, and then let's put all the
methods in a pinky color. So addVisual is a method, selectVisual, findVisIndex,
menu items selected. So have I got all of them? Let's have a look, oh we've got a couple
more that I missed, menuItemOver and menuItemOut, and those are also private
methods of gallery. So the next thing to
do is just to try and understand what this
object is doing. So we can see that we've got this thing
selectedVisual and we can see that we have in our public method that we
are able to add a visual. Now if I go back
to the sketch JS, you can see that what seems to be happening is
that we're adding those different types of graph, which each have their
own constructor function to this object called gallery. So what we could say here is the our gallery objects
registers visuals. They stores them. Maybe I'll put stores above that just in case you're
unclear, stores. Let's see what else the gallery object does
once we've added a visual. So if we look into that method, it checks that the visual
conforms to different things. Checks that it has
an ID and a name, and that the name is unique, that we don't add them twice. Then it stores them in
visuals in the array, and then it creates some menu item here for that visual and
adds it to the DOM. Then adds various event handlers which are our private
methods there. So let's say that it stores
or registers visuals. It creates DOM elements for them. It adds event handlers. Let's see if it's doing
anything else, it's checking. It has something
called pre-load and then it calls that pre-load
method for that visual. So it calls pre-load
if necessary. So addVisual method is doing
all of those things there. We now know that visuals is just an array to store visuals, and we know that these three
items, Menu Item Selected, menuItemOver, and menuItemOut
are event handlers. So now this will make sense if we run our app and
think about this. Well, menuItemOver is
probably being called when my mouse goes over each
of these menu items. Menu Item Selected is happening when I
click the menu item and menuItemOut is happening when my mouse leaves one
of these areas. So that's what those
event handlers are doing. If we look back at the code in gallery and we look
at one of them, you can see that we using p5 DOM code to add a clause
to that particular element, and that clause say
I look up hover, If I was to look at mystyle.css you'll see the hover sets the background
to light gray. So that's how that
functionality is working. So let's have a look what happens when Menu Item is selected. You can see there's some more, what happening with the
DOM in order to color that menu item the right color. But also you can see the another one of the private
methods is being called. The one that's
called selectVisual, and being passed in to that
is the ID of that element. So the ID of that element is going to be the name of
the visual to be selected. So then if we look at
what selectVisual does, is it takes the ID, and it uses the other
private method, findVisIndex to find where it's places in that
visuals array. Then it will call
the destroy method, if necessary of whatever the
current selectedVisual is. Then it sets a new one to
be the particular visual. Then it calls a setup method, and finally it seems to call
[inaudible] loop method. Because it seems like
perhaps the loop method is being turned on and off here. So this selectVisual function, we need to write some of this up. We could say that it
uses an ID to find the correct visual in visuals and it calls setup
on the new visual, and it calls destroyed
on the previous visual. Finally, stores visual in selected visual property. So that method does
all of those things. We now know that find
this index finds visual position in an array given the ID. We could say ID string, because the ID is a string. So we've got some idea of how this gallery object is working. So let's see how gallery fits in with the larger
framework of our app. Well, we can tell that if we
look at our sketch JS that our P5 app definitely has
an object called gallery. So I think we could put it here. We know that gallery
object is also interacting with the HTML DOM. So actually, if I
look back at gallery, I wonder whether we could see. Yes, we can see that it is interacting with something
called visuals menu. If I look at index, can I see? Yes, look, there is an item, which has the ID visuals menu. So I could add that information here into my little HTML section. So let's write down roughly
what we know gallery does. It stores visuals, it creates
items in visuals-menu, it interacts with
items on visuals menu. Let's take a look now at
some of the other objects. If we look back at app again, we can see that
each time we create a visual and add
it to the gallery, we're using a
different constructor. So we've got tech diversity,
race tech diversity gender, and all of these different one. So if I have a look at them. So let's have a look at
tech diversity race, we can see the constructor
function there, tech diversity gender, we
can see that one there, and let's have a look at
what other ones we can see. I go back to sketch JS, pay gap by Job, said about this one
here, and so on. Now, all of these
different objects are added to the gallery
and the gallery assumes that they have
certain things in common. So if we look here, we might find some of these. So it checks for a
property called ID, it checks for a
property called name. What we want to do is
we want to find out what things are common to all of these different
objects and make a meta objects or record a meta object which we could call for ones have
a best word visual, and that's what I'm
going to do now. So let's write that visual, as I said we can see that
it checks inside gallery to see a visual has
a property called ID and it has a
property called name. If we check these different ones, we can see it's got
name and it's got ID. Let's check a different one, it's got name and it's got ID, we'll check another one, name, ID, and we can see that as well. So these are all
public properties. So in our public section, we'll write name,
and we'll write ID. I wonder what else
we've got there. So I can see a couple more
public properties in this one. One's called data and
one's called loaded. Shall we see if they are
in the other objects. This one has loaded, and then I can see that
it also uses data here. Let's check this one,
data and loaded, and I'll check this
one data and loaded. So yes, we have all
of these ones as public properties
and I will color them blue there, that properties. Good. Let's see what else
we've got in terms of methods. Well, if we look
back at the gallery, we can see that's, let me see, it checks for
something called preload, and then encodes it if
it exists in the visual. If I check some of these visuals, you can see that they
have this implemented. Here we are, here's
method preload. If I check gender, that's a method preload, lets check this one, yes, that's preload, and
pay gap time series, yes, here we are,
it has preloaded. So I can add this one, we have preload, and we can
also see set-up and destroy. If we check back in our gallery, we'll see somewhere that setup indeed is being called and
destroy is being called. So I think it's safe
to put those there, and also is there anything else that is
being called there? Well, we can't see
anything in gallery, let me just check. So in our main app, we can see that whatever is the selected visual draw
is being called as well, and if we look at each
of these visuals, they always have a
method called draw, which makes sense really because they need some way
of drawing themselves. We'll find this one draw as well. Draw, yes, good. So I'm going to color
all of these ones pink as these are public methods. So we've described now the
common bits of visual, and it might be worth
just saying where these different things are called from just for reference. So preload, if you have
a look in gallery, preload is called by
the artificial method. So I might just put an
arrow which is this and say called by gallery.add visual, and set up and destroy is
also called by gallery, but it's called by select visual. So these two here called by
gallery as select visual, and draw is called by P5 app. So we might want to just look at what name and ID are
in these things. So maybe we can see that. So we can see the name and ID, this are both strings, they are both strings. Data seems to be looking at this, this is where the actual
data is loaded into. It might not be the
same thing in each one, but we can say data is stored. Finally loaded, if
we have a look, loaded is used to check whether the drawing
should happen or not. So we could just put
loaded is used by tool. So we've looked at what all the different
visuals have in common. Now, let's start looking at each different
visual in detail. I'm going to start
with the one that I think is simplest here
which is PayGapByJob. You can see that it's jointly
owned by the gallery, but it's also being
created in p5 apps. So to represent that, I'm just going to draw
a line that comes off of both of them and I'll
put here PaygapbyJob. Tricky to write that. If we have a look in that class, we can see the various
things already, but we talked about
the public properties. We can see that the data
has been loaded from a CSV file using p5's
load table function. You can see that in
the drawing section, it may show that tables actually being loaded before
it does the drawing. Then we see a method
called Add Axes Code, and that just draws some lines. You can see those lines being drawn there in a private method. Then, you can see some methods being called
from helper functions. So if we look in
helper functions, you can see that there's
the method called stringsToNumbers and that will convert items in
arrays to numbers. If I go back again
Pay Gap By Job, can we see anything else? We'd see those done, we see some variables being
set, and finally, we see iterating
through our data, and then there's some code
left for you to complete. So at the moment, if I click on Pay gap by job, you can see all that actually
gets drawn of a two axes. So now, that we've looked
at Pay gap by job, let's have a look at this
object TechDiversityRace. So if we have a look here, we can see the file
TechDiversityRace. Have a look there. We can see as with
the other ones, we can see a constructor
function and we can see name, an ID, and data, and loaded. But now we can also
see something else. This is a little bit complicated. We're creating an object inside with
constructive function, and it's being stored
in a private variable, and the object code is using the constructor
function pie charts. So we're going to end up with two things that we're
going to need to look at. So if I haven't looked down, we can see the data being loaded, and there's not much in setup
or destroy as things stand. But if we look in draw, we can see that pie, which is of the
object-type pie chart, has a col to it's method draw. So if we have a little
look in our files, we can see there's another
file called pie chart. In pie chart, you can see that there is a
method called Draw. That's publicly available method. It takes the data, it takes the labels, the colors, and the title. So I'm going to have a guess that labels might be an array. Yes, we can see that labels
is being treated as an array. Colors as well. We can see the colors here. We have colors.length. So colors is an array. I would guess that title, on the other hand, is
probably a string. Yes, we can see it being
used and drawn with a text commands here as a string. So if I'm going to add
this one to my diagram, I'm going to put the parent
class, not class, sorry, the parent object, which
is TechDiversityRace, so let me put that. "TechDiversityRace."
We'll put that there. But now, this
TechDiversityRace object has another object called Pie. Is it pie or pie charts? I should say PieCharts. Well, we've got three
more visualizations here to look at. We've got the climate change 1, we've got tech
diversity by gender, and we have the pay gap. Rather than going through
these ones in detail, I just want to point
out one thing about what's in common with all
three of these visualizations. So if we have a look, for example, at
TechDiversityGender, we can see that unlike the other visualizations
that we went through, they create a new
object called Layout. If you remember layout is that constructive
function that existed at the bottom of helper functions and it takes a margin size. You can see what's in common with these different
graphs is that they have the same types of axes there and that's why they have
these layout objects. So I'll just show you as
well in climate change, you can see the
layout created there. If we look at pay gap as well, you can see the
layout created there. So I'm going to add
these to my diagram. So if we go back
to our sketch js, we can see there that we've got PayGapTimeSeries, we've got ClimateChange, and we've got
TechDiversityGender. So I'll draw boxes
around each of these. We know that each of these
objects has a layout. So we can join those there. Okay. So that's a
basic under the hood, a look at our data
visualization app. Make sure that you've
gone through this carefully and really
explored the code. You might want to
have a closer look at those last three visualizations and see if you can work
out how they work.


________________


Week 7 4.204 Data visualisation application: under the hood


Okay. So I've got the data visualization app
open here in brackets. You can see there's
a lot of files, it's a little bit daunting, so let's start by looking at
what is most familiar to us. So looking back at my index.html, we can see there's lot's of other scripts being loaded
that we could look at. This ones, these
visualization files all look pretty specific, so I want to start with
the more general things. So looking here, I'm
just going to start with the first one,
helper functions.js. So if I dive into this file, I can see that there are
a load of functions here, and actually once I start
investigating these functions, so I can see they're
all quite independent, they're not attached to
anything else in the program. So if I look at
what this one does, it basically sums what looks like might be an array of numbers
and returns the title. This one finds the mean
of a load of numbers, and this one here converts an array of strings to numbers. We've also got other ones that draw axis for
our visualization. One thing you might
notice with these one is that they all take something called
layouts as an argument. If we're wondering
what layouts is, we can see its layouts got some properties here like left margin and bottom
margin that they miss. So it's definitely expecting
something specific there, and if we scroll
down to the bottom, and so that's our
helper function file. So if you look here, you can see that we've
got an index.html, so I've got that one open. Let's have a look at what
libraries we're using, and I can see here that
I'm using p5.min.js, so I'm using p5 js. So I think on my drawing I'm going to write that in
the top left-hand corner. P5 js is one dependency, and you can see we're also
using p5 dom as well. Let's get that, p5
dom. Not really. There we go. I might just
color my dependencies as well, we'll just go for gray
right over there, so that would be my
code for dependencies. I can see that there
are lots of extra falls but we still have a sketch.js. So I think that that's
where I'm going to go next. So let's have a look
at the sketch.js, and everything looks
as we might expect. We have a setup function and
we have a draw function. So I'm going to call
that my p5.js app, so we'll put that
little box there. So let's say p5 js app. That p5 js app is going to be interacting with an HTML page, the one that we just
looked at before, so I'll add an extra
box for my HTML. Actually, if I just drop back to the HTML, let's have a look, we can see that there is
some styling going on. There's a style.css file. So if I have a
quick look at that, and you can see there
are some clauses there, so let me add that one. So for the moment, I'm just going to
leave that large there and we'll now go and
have a look at in a bit more detail at what's going
on in the setup function. So the first thing I
can see is that we have some p5 dom code which gets
an element of the ID app. So if I have a look
back at the index.html, can I see some code
that has ID app? Yes, we can see it here, there is a div and its id is app. So I think I'll just make
a little note of that. I'll put the hashtag
app there to show that. If I go back again
to my sketch js, you can see that we
create a canvas, and we set its parent to app. So what we're doing is we're
making a canvas element and then we are putting that
canvas inside of that div. Is there anything else in
terms of interaction there? Not for the moment. So that's fine. What I think I'll just
do to finish this little bit off is I will draw a box around all my stuff that is
to do with HTML and CSS, because it's a separate world, and I'll just do maybe
a little dotted line between my p5 JS app to show that I've got some interaction
going on there between my app and that world
of HTML and CSS. So looking back at my index HTML, I can see all these other
files that are being loaded. So these ones look
quite specific, the main visualization files. So I think what I want
to do is just start with some things that are more
generally used across the app, and I can see that one
of the first scripts that is loaded is
helper functions. So let's have a look
inside that file. If I look here, I can see that there are just functions that
are independent. So this one seems to, if I look at this, it takes in some data and
it makes some of the data, and it also looks
like it's converting, making sure that that
data is actually numbers so that it is
able to be summed. This one is taking
a mean average. But these are all things that are not connected
to anything else, they're isolated functions that can operate independently. So that's good,
that's being loaded. I think what I'm going
to do is draw a box for that here, helper functions. Maybe we should just describe a little bit for our
own reference what they do. So if we look at what these different functions in helper functions actually do, we can see that some of
them are drawing functions. So for example,
this one is drawing some labels on y-axis of graphs, and some of them are
just processing data like the sum function
or the mean function. So I think next to this block I'm going to write
what these things do. So there is data processing, and there is drawing
for this going on. I think I'll put a
little line just to show the connection
between my main app and the fact that it can
use helper functions. The other thing that you'll notice is some of
these functions, if I have a look, so
when you draw axis, this one, uses something
called layout, and we can see that layout is a particular type
of objects there. So this object has a top margin, a bottom margin. What
else can we see? A left margin, a margin size, and I'm not sure, I'm going to have a look here. I can't see layout
defined there yet, we just see it used as an
argument for several functions. But definitely helper
functions needs to know about this
thing called layout. So I'm just going to put
it here for the moment, and we'll find out hopefully
where it is defined later. So I'm looking back at
the sketch.js file, and the next thing I
can see is that we are creating an object
called gallery. Because of this new keyword, I can tell that there is a constructive function
for this thing gallery, but I can't see it here
in my sketch js file. But if I look down
at my list of files, I can see something
called gallery.js, and I bet it's probably there. Now, just to confirm that that's being used by my program, I will have a quick
look and see that it's being loaded in the index.html, and I can see it
there, gallery.js. So let's have a look
inside this file. When I look inside, straight away I can see
that indeed there is a constructive function
called gallery. So what I'm going to do, I think, is because this is
quite a big object here that's being created, I'm going to have a
separate note to draw out the various
things in gallery. So let's do that now. Gallery. Okay so let's have a look. We've got some public
properties here. We've got something
cool selectedVisual. So I'm going to put
that in selectedVisual. We don't have any other
public properties, but we've got some private ones. We've got one now you've
seen this person before. We got one called self which is just a
reference to the object. So I'm not really going to
bother noting that one. But we do have this one
that looks important, and that's called visuals. So I'm going to draw books for my object, and in the top half we
have the public area, and in the bottom half we
have the private area, let's make this a bit
neater [inaudible] really a bit messy there. So we've got our properties done. Now let's have a look and see what happens in terms of methods. Well, I can see that I've got a public method called addVisual, and then I have
some private ones, one called selectVisual and
findVisIndex menu item, in fact, it's quite a few. So let's list these
down in my object. So we've got addVisual
in the public area, and then in the private
parts we've got selectVisual and find this index and we've got menu item selected. So what I'll do is just to
color-code this so that I can tell quickly
which is which. I'm going to put all
the properties in blue, so there's one selectedVisual
and Visuals here, and then let's put all the
methods in a pinky color. So addVisual is a method, selectVisual, findVisIndex,
menu items selected. So have I got all of them? Let's have a look, oh we've got a couple
more that I missed, menuItemOver and menuItemOut, and those are also private
methods of gallery. So the next thing to
do is just to try and understand what this
object is doing. So we can see that we've got this thing
selectedVisual and we can see that we have in our public method that we
are able to add a visual. Now if I go back
to the sketch JS, you can see that what seems to be happening is
that we're adding those different types of graph, which each have their
own constructor function to this object called gallery. So what we could say here is the our gallery objects
registers visuals. They stores them. Maybe I'll put stores above that just in case you're
unclear, stores. Let's see what else the gallery object does
once we've added a visual. So if we look into that method, it checks that the visual
conforms to different things. Checks that it has
an ID and a name, and that the name is unique, that we don't add them twice. Then it stores them in
visuals in the array, and then it creates some menu item here for that visual and
adds it to the DOM. Then adds various event handlers which are our private
methods there. So let's say that it stores
or registers visuals. It creates DOM elements for them. It adds event handlers. Let's see if it's doing
anything else, it's checking. It has something
called pre-load and then it calls that pre-load
method for that visual. So it calls pre-load
if necessary. So addVisual method is doing
all of those things there. We now know that visuals is just an array to store visuals, and we know that these three
items, Menu Item Selected, menuItemOver, and menuItemOut
are event handlers. So now this will make sense if we run our app and
think about this. Well, menuItemOver is
probably being called when my mouse goes over each
of these menu items. Menu Item Selected is happening when I
click the menu item and menuItemOut is happening when my mouse leaves one
of these areas. So that's what those
event handlers are doing. If we look back at the code in gallery and we look
at one of them, you can see that we using p5 DOM code to add a clause
to that particular element, and that clause say
I look up hover, If I was to look at mystyle.css you'll see the hover sets the background
to light gray. So that's how that
functionality is working. So let's have a look what happens when Menu Item is selected. You can see there's some more, what happening with the
DOM in order to color that menu item the right color. But also you can see the another one of the private
methods is being called. The one that's
called selectVisual, and being passed in to that
is the ID of that element. So the ID of that element is going to be the name of
the visual to be selected. So then if we look at
what selectVisual does, is it takes the ID, and it uses the other
private method, findVisIndex to find where it's places in that
visuals array. Then it will call
the destroy method, if necessary of whatever the
current selectedVisual is. Then it sets a new one to
be the particular visual. Then it calls a setup method, and finally it seems to call
[inaudible] loop method. Because it seems like
perhaps the loop method is being turned on and off here. So this selectVisual function, we need to write some of this up. We could say that it
uses an ID to find the correct visual in visuals and it calls setup
on the new visual, and it calls destroyed
on the previous visual. Finally, stores visual in selected visual property. So that method does
all of those things. We now know that find
this index finds visual position in an array given the ID. We could say ID string, because the ID is a string. So we've got some idea of how this gallery object is working. So let's see how gallery fits in with the larger
framework of our app. Well, we can tell that if we
look at our sketch JS that our P5 app definitely has
an object called gallery. So I think we could put it here. We know that gallery
object is also interacting with the HTML DOM. So actually, if I
look back at gallery, I wonder whether we could see. Yes, we can see that it is interacting with something
called visuals menu. If I look at index, can I see? Yes, look, there is an item, which has the ID visuals menu. So I could add that information here into my little HTML section. So let's write down roughly
what we know gallery does. It stores visuals, it creates
items in visuals-menu, it interacts with
items on visuals menu. Let's take a look now at
some of the other objects. If we look back at app again, we can see that
each time we create a visual and add
it to the gallery, we're using a
different constructor. So we've got tech diversity,
race tech diversity gender, and all of these different one. So if I have a look at them. So let's have a look at
tech diversity race, we can see the constructor
function there, tech diversity gender, we
can see that one there, and let's have a look at
what other ones we can see. I go back to sketch JS, pay gap by Job, said about this one
here, and so on. Now, all of these
different objects are added to the gallery
and the gallery assumes that they have
certain things in common. So if we look here, we might find some of these. So it checks for a
property called ID, it checks for a
property called name. What we want to do is
we want to find out what things are common to all of these different
objects and make a meta objects or record a meta object which we could call for ones have
a best word visual, and that's what I'm
going to do now. So let's write that visual, as I said we can see that
it checks inside gallery to see a visual has
a property called ID and it has a
property called name. If we check these different ones, we can see it's got
name and it's got ID. Let's check a different one, it's got name and it's got ID, we'll check another one, name, ID, and we can see that as well. So these are all
public properties. So in our public section, we'll write name,
and we'll write ID. I wonder what else
we've got there. So I can see a couple more
public properties in this one. One's called data and
one's called loaded. Shall we see if they are
in the other objects. This one has loaded, and then I can see that
it also uses data here. Let's check this one,
data and loaded, and I'll check this
one data and loaded. So yes, we have all
of these ones as public properties
and I will color them blue there, that properties. Good. Let's see what else
we've got in terms of methods. Well, if we look
back at the gallery, we can see that's, let me see, it checks for
something called preload, and then encodes it if
it exists in the visual. If I check some of these visuals, you can see that they
have this implemented. Here we are, here's
method preload. If I check gender, that's a method preload, lets check this one, yes, that's preload, and
pay gap time series, yes, here we are,
it has preloaded. So I can add this one, we have preload, and we can
also see set-up and destroy. If we check back in our gallery, we'll see somewhere that setup indeed is being called and
destroy is being called. So I think it's safe
to put those there, and also is there anything else that is
being called there? Well, we can't see
anything in gallery, let me just check. So in our main app, we can see that whatever is the selected visual draw
is being called as well, and if we look at each
of these visuals, they always have a
method called draw, which makes sense really because they need some way
of drawing themselves. We'll find this one draw as well. Draw, yes, good. So I'm going to color
all of these ones pink as these are public methods. So we've described now the
common bits of visual, and it might be worth
just saying where these different things are called from just for reference. So preload, if you have
a look in gallery, preload is called by
the artificial method. So I might just put an
arrow which is this and say called by gallery.add visual, and set up and destroy is
also called by gallery, but it's called by select visual. So these two here called by
gallery as select visual, and draw is called by P5 app. So we might want to just look at what name and ID are
in these things. So maybe we can see that. So we can see the name and ID, this are both strings, they are both strings. Data seems to be looking at this, this is where the actual
data is loaded into. It might not be the
same thing in each one, but we can say data is stored. Finally loaded, if
we have a look, loaded is used to check whether the drawing
should happen or not. So we could just put
loaded is used by tool. So we've looked at what all the different
visuals have in common. Now, let's start looking at each different
visual in detail. I'm going to start
with the one that I think is simplest here
which is PayGapByJob. You can see that it's jointly
owned by the gallery, but it's also being
created in p5 apps. So to represent that, I'm just going to draw
a line that comes off of both of them and I'll
put here PaygapbyJob. Tricky to write that. If we have a look in that class, we can see the various
things already, but we talked about
the public properties. We can see that the data
has been loaded from a CSV file using p5's
load table function. You can see that in
the drawing section, it may show that tables actually being loaded before
it does the drawing. Then we see a method
called Add Axes Code, and that just draws some lines. You can see those lines being drawn there in a private method. Then, you can see some methods being called
from helper functions. So if we look in
helper functions, you can see that there's
the method called stringsToNumbers and that will convert items in
arrays to numbers. If I go back again
Pay Gap By Job, can we see anything else? We'd see those done, we see some variables being
set, and finally, we see iterating
through our data, and then there's some code
left for you to complete. So at the moment, if I click on Pay gap by job, you can see all that actually
gets drawn of a two axes. So now, that we've looked
at Pay gap by job, let's have a look at this
object TechDiversityRace. So if we have a look here, we can see the file
TechDiversityRace. Have a look there. We can see as with
the other ones, we can see a constructor
function and we can see name, an ID, and data, and loaded. But now we can also
see something else. This is a little bit complicated. We're creating an object inside with
constructive function, and it's being stored
in a private variable, and the object code is using the constructor
function pie charts. So we're going to end up with two things that we're
going to need to look at. So if I haven't looked down, we can see the data being loaded, and there's not much in setup
or destroy as things stand. But if we look in draw, we can see that pie, which is of the
object-type pie chart, has a col to it's method draw. So if we have a little
look in our files, we can see there's another
file called pie chart. In pie chart, you can see that there is a
method called Draw. That's publicly available method. It takes the data, it takes the labels, the colors, and the title. So I'm going to have a guess that labels might be an array. Yes, we can see that labels
is being treated as an array. Colors as well. We can see the colors here. We have colors.length. So colors is an array. I would guess that title, on the other hand, is
probably a string. Yes, we can see it being
used and drawn with a text commands here as a string. So if I'm going to add
this one to my diagram, I'm going to put the parent
class, not class, sorry, the parent object, which
is TechDiversityRace, so let me put that. "TechDiversityRace."
We'll put that there. But now, this
TechDiversityRace object has another object called Pie. Is it pie or pie charts? I should say PieCharts. Well, we've got three
more visualizations here to look at. We've got the climate change 1, we've got tech
diversity by gender, and we have the pay gap. Rather than going through
these ones in detail, I just want to point
out one thing about what's in common with all
three of these visualizations. So if we have a look, for example, at
TechDiversityGender, we can see that unlike the other visualizations
that we went through, they create a new
object called Layout. If you remember layout is that constructive
function that existed at the bottom of helper functions and it takes a margin size. You can see what's in common with these different
graphs is that they have the same types of axes there and that's why they have
these layout objects. So I'll just show you as
well in climate change, you can see the
layout created there. If we look at pay gap as well, you can see the
layout created there. So I'm going to add
these to my diagram. So if we go back
to our sketch js, we can see there that we've got PayGapTimeSeries, we've got ClimateChange, and we've got
TechDiversityGender. So I'll draw boxes
around each of these. We know that each of these
objects has a layout. So we can join those there. Okay. So that's a
basic under the hood, a look at our data
visualization app. Make sure that you've
gone through this carefully and really
explored the code. You might want to
have a closer look at those last three visualizations and see if you can work
out how they work.


________________


Week 9 - 5.101 Your project
I'm going to give you a rundown on things
you should be including in your midterm assignment and a few pointers to help you
get ahead with preparing your submission. There are several reports sections for
you to complete and a code upload. Don't worry if your code is
still a work in progress, that is exactly what we're
expecting at this stage. We want to be able to make sure
you are on the right lines and that things are progressing effectively. Your code should be compressed
as a .zip file for upload. Please don't use any other
compression formats, as it can slow down our marking process. You submit the report sections
directly into the assignment page. I would recommend writing them out
in a word processor or notes app and then copying them over. Don't forget that these
are rich text edit fields. So you should be using headings and images
where appropriate to describe your work. You can also use bullet points
to help you be more concise, but still try to be as detailed as possible. The first report section is to
give an overview of your project. Which extensions are you building, and which template have you
chosen to build upon? As you write about the extensions,
include the coding techniques you have or expect to use in putting it together. Where do you think there might
be challenges and difficulties? The word limit for
this section is 400 words. We will allow you up to 10% over,
so up to 440 words, but above this and you will lose all
the marks for the quality of your writing. The word counts for
each of these sections is quite tight. Make sure you think about the language
you are using in each section, and be as concise as you can. You may find it best to give surface
information for most of the extensions and then go into more detail about one or two. The next section asks you to respond
with progress you have made so far with the project. This is your opportunity to
recount the brainstorming and design work you have done
up to the submission. You can also describe any code
that you have already written and how efficiently you were
able to produce it. In this section in particular,
it will be important to use images to describe your work such as code or
interface diagrams. Again, showing these as
works in progress is fine. We don't mind rough sketches and
handwritten notes. The important thing is that
we can see a process and ideally a refinement
of your initial ideas. Again, the word count for
this section is 400 words. The next report section is where
you will detail your time planning. We would like you to
use a Gantt chart here, although we'll be open to other
forms of time activity diagram. You can include this by creating
an image of the chart or even a screenshot if that's easier for
you. Make sure you also describe
the Gantt chart and why he you have allocated these
amounts of time to certain tasks. For this section, you have 200 words. The final section you
need to provide text for is to list any external sources
you have used in your project. This might be little sections of code
that you have copied from online or algorithms that you have adapted
to fit in with the template. You don't need to include
everything you have read or guidance on basic syntax you have used. However, you should be including sources
that have helped you to fix bugs such as stack overflow. You should also list any libraries
outside of p5, p5.sound, and p5.dom. You also need to make sure, where you
have adapted code from online and other sources, that it's labeled in the comment section
as well as here in this report section. It is very important to identify
where code is not your own. Its inclusion is not a problem and
encouraged. We can give you marks for effectively
adapting or integrating code of others. But not making this clear can result in
an academic misconduct investigation and a penalty applied to your marks. So please don't do it. There is no upper word count for
this section. When marking, we will be looking at
the overall scope of your project and assessing its complexity. We don't want you taking on too much or
not enough so you aren't able to get
the mark you deserve. We'll also look at how much
progress you have made so far. These two things combined should give
you a good indication as to whether your project is on track. Alongside this we will assess the quality
of your design work and planning. Finally, we will award marks for
the quality of your writing. It's important to proofread carefully and
make sure you stick to those word counts. Best of luck with the midterm, and make sure you review the materials
from the start of the last topic. That's the project overview and
brainstorming and scoping video.


________________


Week 9 - 5.102 Introduction to Programming II project
The assessment for this module is to extend one of the three template applications with your own tools or visualisations. You have now seen all three of the templates and will have to choose one to build upon for your project.
You should use one of these three template downloads for completing the project. These versions of the applications don’t include the incompletions and issues of the case study version you will have downloaded earlier.
We will provide you with example extensions for each application over the next three topics you can use these as help and as a start point. Mostly we will show you the implementation of the extension outside of the template, so they will need to be adapted to work within the app. Also, we will be expecting you to improve on these initial implementations and include additional extensions based on your own ideas. You can only include a maximum of two of the extensions from Topics 5, 6 or 7 in your final submission
The exact number of extensions you should include in your submission depends upon their complexity and programming techniques you use. You should consult the mark scheme and ensure that you have included the techniques listed in extensions you have written as well as the ones we have shown you. In addition you can use the following example projects as a guide.
Submission guidelines 
We have set a few additional guidelines to ensure that your application is easy to mark and you won’t accidentally plagiarise the work of others. Please adhere to the following guidelines.
Plagiarism
* You should not include any code that is the same as another student's. We will be using plagiarism detection software across all submissions to detect similarities.
* If you have sourced code from the internet, make sure you clearly label it in both the code and in the correct section of the midterm and final report. 
* Do not host code on publicly available version control repositories (i.e. GitHub) before or after the submission.
Failure to follow these rules can result in an academic misconduct investigation, you can find guidance on plagiarism in the University of London's General Regulations.
External resources
* Your code must not make use of an external server; including both one you have setup or one that is run by a third party. To mark your work we should only need to open the code in Brackets and launch the application.
* If you use an external library, you must use a local version of the code not a web link to a CDN service.
Project deliverable
You will submit two project deliverables: a midterm assignment that will be set in Topic 6 and the final submission in Topic 10.  
Midterm
For this assignment, you will need to submit the code you have produced for your project to date and written responses to the report prompts in the ‘My Assignment’ tab. 
The aim of this assignment is to make sure that your project meets the requirements for the main submission at the end of the module and that you have made sufficient progress so far. The assessment of your project will also be based on use of design and planning techniques, and the quality of your writing.
Final submission
In this assignment you will need to submit the finalised code you have produced for your project and a further short report. In the report you will outline your project, discuss the effectiveness of the plan and write a short evaluation of your code.
You will be assessed on the quality and complexity of your code, its stability and the answers you provide for the report.  




________________


Introduction to Programming II: Example
final projects
The following project examples the scope and scale of final projects that
would score over 50, 60 and 70% in the final project mark scheme.
Bear in mind that if you replicated these projects exactly, you may not
get the same mark, as the quality and complexity of the coding are being
assessed. They represent our expectations for the size and difficulty of a
project that could score these grades. An outstanding mark can be
achieved with any of the template projects.
A project that scored over 50%
Barry undertook a project using the music visualisation template:
• Barry implemented and improved the ridge plots extension,
rotating it, changing the scale and colours.
• He implemented a new extension that displayed the wave
pattern in a circular shape.
• He implemented a new extension that displayed a series of
overlapping rectangular shapes that changed size depending
on the volume of different frequencies in the music.
• He attempted to allow the user to start the microphone and
use this to drive the visualisation instead of music playback.
However, the implementation didn’t work as intended if music
playback had already begun.
A project that scored over 60%
Sally undertook a project using the drawing application template:
• Sally implemented the stamp extension, enhancing it with the
ability to select from a drop down list of elements.
• She implemented the editable shape extension, enhancing it
such that the user can choose between straight lines and
curves between the points.
• She implemented small extensions for drawing ellipses and
rectangles that could be filled or unfilled.
• Sally created an eraser that can change size.
• She also implemented a simple spirograph tool. The tool draws
a spirograph in the centre of the canvas with user controls for
changing the size of the spirograph.
A project that scored over 70%
Carrie built upon the data visualisation template:
• Carrie enhanced the tech diversity visualisation to utilise a
donut chart with the data displayed in the centre of the image
when each segment was hovered over.
• She improved the pay-gap tool by colouring with different
intensities of red to show how far the organisation was from
the centre of the chart and pay parity.
• She used waffle charts to show the results of a survey on
climate change attitudes between university students and the
rest of the population.
• She found a dataset of population density by UK county online,
Carrie cleaned the data and used in a heat map of the UK. The
UK county map was also found online in the SVG format. She
also implemented simple zooming and panning controls for the
map
• Carrie also found dataset of Internet usage by age and gender.
She used it to create a circle diagram. The circles were colour
coded and sized relative to the number of user in each group


________________




Final Grading requirements

  
  

  

  
  



________________


Week 9 - 5.103 Brainstorming and scoping


At the end of the next topic, we are going to be setting
your midterm assignment. For this assignment,
you're going to have to write a short report about your plans for the project and to submit
your initial coding. Before we get there, let's
take some time now to go over the process of scoping your project and
brainstorming your ideas. Please don't skip over this one. There is some important
information for your submission and
what we're looking for. Any software project has amongst others a major
limiting factor. Whether it is for a
university project or one of the Silicon Valley 'behemoths' there is
an unbendable resource that will always run
out and that's time. Your projects scale
and scope will be dictated by what you can produce between now
and the deadline. Software can be
quite unpredictable. It's easy to get lost in
a bug for far too long. But with full thought
and careful planning, you can reduce the
risk to your projects. For that reason, we are
asking you to produce a short report on your
project plan for the midterm. A good place to start
the process is to brainstorm a series of
extensions and refinement ideas. Come up with as many as you can. You can seek inspiration
from similar applications you may have used or seek
out examples online. You're not looking
for code to copy, but for examples of implementation from
real-world applications. Perhaps, you can try out some of the vintage examples of drawing applications or scan newspaper websites for
inspiring visualizations. I would suggest you go
through this process for each of the
template applications, then you'll be better informed as to which one to undertake. Over the next three topics, Simon and I are going to
be showing you a series of potential extensions you might want to build on for
your applications. For your project, you will
be allowed to include variations of two of
these extensions. When you've done some
research of your own and watched our videos, the next stage in this process might be to rank your
ideas for difficulty. You can use the extensions
we have shown you as a yardstick for measuring
how complex your ideas are. Some things will be obvious. Say you want to add a rectangle
tool to the drawing app, that will be on the easier end of the difficulty scale
and is going to be a lot like the line
tool in the template. When things get more complex, it can be hard just to gauge. For example, a bucket filter which is actually
a really tricky thing to implement despite being a very common tool
in drawing apps. Maybe start to look if there is a standard algorithm
for implementing it. The case of the
bucket fill there is. So you want to try and walk out which P5 objects you might need to implement
this algorithm. Other extensions might not be as readily solvable with a
single algorithmic solution. A very complex
extension might be to add basic layer support
to the drawing app. This requires thinking about the user interaction
as well as the code. What features do your layers implement to support
certain drawing techniques? Perhaps, you could use
diagrams of both the code and the interface here to understand the complexity
of the problem. When you have your ordered
list of extensions, you need to work out which
you are going to undertake. Don't forget to include the
extensions we have shown you and think about how you're
going to improve on them. You may also want to
rank your extensions by other metrics such as usefulness or creative valley
when making your decision. Now would also be a good time to review
the mark scheme for the project and make sure that the extensions you
are picking are going to get you
the marks you want. In your midterm report, you are expected to provide evidence of the planning process. Whether you have used the techniques from
this video or not. This might include
descriptions, diagrams, and the evolution of design from conception to establishing
the structure of the code, and how you are going
to check if you have implemented it correctly. We aren't looking for full
test plans in this module, but we would like to see evidence that you have
considered how to evaluate the successful
implementation of your extensions. This might be checking
to make sure it works in a series of edge cases or giving your finished app to a few friends to try out
and gauge their opinions. We also want to see
evidence that you've planned out the rest of
the time for your project. A common way to do this is to produce a Gantt
chart like this one, where you've laid out the time that you have
on the project and broken down the tasks and fitted it into the
available space. This is a very useful technique particularly if you're
building contingency time. In your midterm report, we want to see evidence of time planning as well
as code planning. One last thought
to share with you, don't be afraid to
include scrappy diagrams, sketches or scans of
handwritten notes. We want to see the
process you are undertaking in
producing your project. That will always start at
the lower end of fidelity. The rest of this topic, we're going to show you
the first extensions we have built for the apps.


________________


Week 9 - 5.203 Extending the data visualiser: existing data sources


In this video, I'm
going to show you a way to extend the
Data Visualizer. Now, as for data visualizers and little bit more complicated
than the other apps, I'm going to extend
the app directly. When it comes to your project, don't forget that there
are extra marks for improving the extension as well. In this video, we're
going to adapt it to visualize a different data source which will find on the web. The first thing we
need to do is to find an external data
source to visualize. Now, you might struggle for inspiration of where
to look for these. The UK government collects some collates data to inform
how they make policy, and they publish a lot of this file their website
@gov.uk/government/statistics. Scrolling down this list, I hope you can see that many of these data collections relate to contentious areas of policy which frequently
appear in the media. Creating our own
visualizations of this data can provide valuable
independent insights. I've decided to focus on food. Data about food production and consumption impacts so many areas of political debates
including public health, the cost of living,
and food security. I'm going to navigate
them now on the sites. So we'll just do a
search for food, and the first thing we find is the food statistics pocketbook. If I click here, you'll find that we can look at a summary of all the data that's being collected around
food statistics. There's some really
interesting stuff in here and already some data visualizations. So you can see things
around food productivity, but also see how much consumers spent on different items and how the price of food
has changed and so on. But what we're really
interested in is the rotator, because we can use that for
our data visualization app. If you scroll down, you'll see that CSV files comma separated value
files that we can use. The particular one
I'm going to use in this case is going
to be this one, "Attitudes towards
British food purchases in the UK for the year 2018." So I'm going to download
a CSV file right now. So I've got my data
downloaded as a CSV file. So the first thing
we should do is just have a look at that data. So I'm going to use Microsoft
Excel to open this data. You could also, if you don't have a copy of Excel to hand, you could also just
use, for example, Google sheets to open
files like this. So when I have a look here, I will just drag these bars out. We can see that people, this is data from a survey, that people were asked to respond to statements such
as I tried to buy British food whenever I
can or British food tends to be more expensive
and imported food, and they were asked whether
they strongly agree, agree, neither agree, nor disagree, disagree, or strongly disagree. So there were five possible
outcomes for each response. Then the data that we
have is a proportion of people who strongly agreed with statements or
disagreed and so on. So I think that a
really suitable way of representing this data
is to use a pie charts, so we already have in
our data visualization. So that's great. What do I next need to do is have a look at the pie
chart data that's already being used by my happens see compare it service data
and see how it conforms. So if I go into my data visualization
app and I look in data. Well, it was tech-diversity
data that we used and it was
tech-diversity race data. So I'm going to
open this one with Excel as well and
have a look at it. So we can see that things are a little bit different here in terms of the presentation
of this data. So we have the names of companies going
across the top bar and we have the
different proportions going down the sidebar. So in order to reuse this code, we're going to need to manipulate our data to make
it look the same. So if I go back to
this data, well, what I could do is I could have the different questions along
the top as companies as they are companies in our
race data and I could have the responses down
the left-hand side as we've done with
different ethnic groups. So there's a nice
way I can do this, I think which is to first of all make a new sheet and my questions are going
to go across the top. So I'm going to just
put one of them in each column starting
with column B. Now but it's not
very clear to read. So what I'm going to do is I'm just going to select all of these cells and change the wrapping option so that we can see the
questions clearly there. Good. Now we need to
make the row categories. So we need strongly
agree, agree, disagree, or nor agree, disagree,
and strongly disagree, so it's these five and I'm
going to paste them here. So we're nearly there. All I need to do now is just
copy over the data itself. So this is the question I tried supply purchase
food whenever I can, and here are all my
proportions and I can just copy them over like so. We'll just work our way through them very
carefully making sure that we've copied things
into the correct places. There we go. So I'm going
to now save this as a CSV. So I go to file and
I go to save as, and there's the format is
comma separated values. I'm just going to save
it to my desktop and then I'll move it to
the correct place. So I can call it
attitudes to UK food and we'll just put 2018. I will choose to save
the active sheet. As I've said, if you don't
have Microsoft Excel, you can do this in Google Sheets which is free for anybody to use, you just need to
set up an account. So before we start using
this data in our app, let's just take a quick
look at the rule CSV and make sure that everything has been rendered correctly. So I'm just going to open
the file with brackets. If we look, the top line
starts with an empty cell and then it has all the
questions as we would expect. Then we get our various
different responses as the first item in
each subsequent row, and the different
values going along. So everything looks as
we expect. That's great. Next thing we need to
do is we need to put it in a useful place
within our app, and our data should be
contained in our data folder. So I'm going to navigate
to the data folder, and I'm going to
make a new subfolder because this is a new category. I'm going to call this one food. Inside food, I will put
my edited app data. Now, the next thing to do is to start making a new object
to visualize this data. So we said we were going
to use a pie chart, and we've already got
one pie chart here which is tech diversity race. Now, I should point
out that I'm using a completed version of
the data visualizer app, but I'm not going to
give you that version because it's a part of
a previous exercise. So at this point you
should be working from your own finished
version to do this. So tech diversity race is the
file that we want to use, but we're going to copy that file and then start adapting it. So if I go back in
my folder structure, I can see tech diversity race. I'm going to copy
and paste it here, and I'll change the name. So let's call this one,
UK food attitudes. The next thing we've got
to do is make sure that that file is being
loaded as well. So we go to index, and on the tech diversity gender we will make a new script tag, and it will be called
UK food attitudes. Oops! I just tried up a little. Excellent. So the next thing is, we want to change the name
of this object because currently it's called
tech diversity race. So let's change it to
UK food attitudes. Finally in sketch, when
we add the new visual, we'll need to add
it without names. So we got gallery.addvisual. I'm going to make a new
object and it's going to be called UK food attitudes. Also now we should probably
change the name and the IDs so that we'll
see that displayed, so I'll do that much. I'm not going to change
anymore for the moment. I just want to see whether
all of this part has worked. So I'm going to start up my app, and I should see a new
item to be selected. There we can see it
is UK food attitudes. Now, of course, if
I click on this, what I actually see is ethnic diversity at
different companies. So we've still got
some more work to do. Let's go back to our code. So if we're looking at the
UK food attitudes file, the next thing we
need to do is to load in the different data. So we hunted tech diversity race, let's change this file path. So we made a folder called food, if you remember, and now I need to remind myself
of a filename. So if I look in data, you've got food, attitudes
to UK food 2018. I think it should have
a.csv extension as well. If I really want to be
safe I can just copy that file name and put it there. Let's have a look and see whether that data has managed
to be loaded by app. So now we've got
an error message. It says, arrays must
be the same length. You can see that we've got five data items,
five data labels, but the colors, we've
got too many colors, and this is because we set up our app to deal with
a different dataset. So let's have a
look through this. So this should be
relatively simple to fix. We just need to get rid
of some of the colors. I think what I'm going
to do here is to try and order the colors
according to their responses. So if we remember in
our data, we started, I might need to look
back at the data, we started with
strongly agree and we worked our way down
to strongly disagree. So it will be nice if
strongly disagree was red and strongly agree was green. So let's see if we can
do that in our app. So strongly agree would
be the first one, so that would be green. I think somewhere in the
middle should be yellow. Then we probably could go orange, and finally we could go red. So we're just missing
one color here. I wonder whether
there is something, maybe we could make
this one dark green and this one green. Let's see if that works. Not sure if there
is a dark green. We'll just refresh this up. It looks like we're just
missing the first color. So maybe we'll try for
light green with a hyphen, let's see if that works. No. I'm going to now have to check the P5
reference to see if we can find a nice label to use for
the color. Lets have a look. So this color, and normally
we can see something. Maybe it's here. We can't see any colors there. Maybe I'll just use
a different method for that one color. So I will go. We could use a hexadecimal
code for that color. So let's just go. So if we go RGB is R G B, and we want to go
with over green. Let's see if that works for us. There we go. So strongly
agree is a light green. Then we go to a dark green, and you can see neither
agree nor disagree there. So most of this is now working. We can see that we've
still got a couple of things that we
might want to do. So this is where we select
the different questions, and it's in the
way of our titles. So let's try and find that bit, that select box and
move it's position. So will now have to find
where that box is created. So here we have this
dot select position is made at position 350, but only 40 from the top. Now, looking at this I think we could put it at the
bottom of the page. So instead of going 40, I think I'm going to put 500 in there and see what
that looks like. That's much better. The other thing is, it says
employee diversity at, and obviously that's not
what we want to have there. So let's have a look for that part where the title is set. So here we are, it says title is. So why don't we just put
question and a colon, and then we can put the question. Now, this looks much better. Now, the other thing
is, there's lots of labeling inside the code that isn't really relevant for the type of data
that we are visualizing. So for example, I noticed
it said company name, and really company name
should be question type. So I think what I could do
is to a find and replace. So for everywhere it
says company name, I'm going to put question type. I'm not sure whether there are any other things that
might need changing. So it says companies, we don't really want companies because that's not
what we're comparing, we're looking at questions. So why don't I
change that as well. So companies and I'll do a find and replace with questions. I'm very diverse data visualization using an
external data source. In the next video,
I'm going to show you a little bit more complicated
version of doing this. In this video, we're
going to attempt a slightly more complex
data visualization. I found a different data
source to work with, but it's also about food. So you can find it on
the GOV.UK website, at the address I'm highlighting
in the browser now. So it's
gov.uk/government/statistical-data-sets/ family-food-datasets. You can see it there as well. If you scroll down on the page for the family food datasets, you can see there's lots
of different files to use. But the particular one
we're going to look at, is UK-household and eating
out nutrient intakes. So I'm going to download
that folder now. Now, you might notice
that the extension is perhaps unfamiliar to
you, it's called ODS, and ODS is an open source
way of sharing data. It can be a little bit
tricky to open the file. You might find that if you have a modern version of
Excel, you can open it. But one way to open
if it's accessible to everybody is to use
Apache OpenOffice, and you can download that
application for free. I go back on my computer, so I'm going to open this
file using OpenOffice now. So once we have that open, you can see that there are
some different tabs here. I'm going to try and find the one that I
want to work with. So I think what I'm going to do, is I'm going to look
at household intakes. The reason I'm doing that
is because it has data going all the way back to 1974. So I think that's quite
interesting to work with. If I scroll down on that tab, I can see average intake as a percentage of weighted
reference nutrient intakes. This is going to show various
nutrients and how much we consumed of them over
the years as households. So I'm going to select
these rows and columns, and I'm going to paste
them into a different app. The reason I'm going to do
this is because OpenOffice, unfortunately, does not
easily export to CSV. So I'm going to open Excel and I'll paste here. So I'm going to tidy up this data a little bit before we start
working with it properly. So I can close OpenOffice now. The first thing is, I don't think that we are going to use this
first column which seems to have some
code numbers to it. Then you got a blank column here, so I can delete that. Then some of these, we need the year data as well. I just forgot to get that. So I have to open
this one more time. My apologies. Let's go back. We have the year data going
from 1974 all the way to 2017 by the looks of things. So you paste that there. One thing I notice is when
I look at the year data, these numbers are going
to cause problems for us where it says 2001-2002. So I'm going to just tidy
this up and put 2001 here, 2002 here, 2003, and so on. Likewise, I'm not sure
what's happened here, but I'm just going to
put 2016 and 2017. The other thing is this data
wasn't collected for some of these items in earlier years. So I'm going to
delete those items. We won't look at those ones. The final thing I notice is, the column for 2017 has
numbers that are much lower. In fact, they're pretty much
half of the numbers for the previous year and
that makes me think that that's incomplete
data for that year. So I'm actually just going
to delete that column. We won't consider that one. That looks like a
pretty clean dataset to me now and so I'm going
to save this as a CSV file. Now once I've done that, I can close my programs and we can start
working with the data. Now, I remind you
that I'm working with a completed version
of the data visualizer. I won't be providing this
one for you with this video, because it's an earlier exercise. So you'll need to
use your own version of the data visualizer that
you've been working on. So the first thing
I'm going to do is to put my data
in the right place. So I've got my food
folder all ready to go, and I'm going to
place it in there. So we've got nutrients from the years '74 to the year '16, and we'll make sure its
got the CSV extension. Now, if I go and run
my app in brackets, and if we think about this data, this is data that runs over
a long period of time. If we look at the different
types of visualization, if I look specifically
a pay gap '97 to 2017, you can see that this is an appropriate format for
showing these sorts of data. So this is the one that I'm
going to copy and adapt. So let's have a look at
the files, first of all. So we've got pay gap 1997-2017. So I'm going to find that one in a folder. Here we are. I am going to give it
a new name and we will call this nutrients 1974-2016. Now we need to go to the index file and make sure
that the file is loaded. So we can put it here. Nutrients that we have. Great. Then, in our sketch.js, before we do that,
we want to go to nutrients and we want
to change the names. So instead of calling
it PayGapTimeSeries, I am going to call it
NutrientsTimeSeries. Let's change the title. So it's 1974-2016. We can change this as well nutrients and we will leave that
one for the moment. We can come back to all of that. So finally, in my sketch.js, I am going to add the visual
to my list of visuals. So we are going to call it add new NutrientsTimeSeries
that we have. If I go back to my app, we can see nutrients. Now, obviously I haven't
actually adopted any of the real code inside that file, so we are still seeing
the wrong data presented. Now, the next thing we
should do is just look at the data the pay gap uses and compare it to
our other data and see whether it is going
to be appropriate or whether we are going to
need to make changes. So let's have a look at that one. I think it will
come on the pay gap and I think it is this one. I am just going to open it with Excel again so I
can get a clear view. So we can see we've got a list going down
with years and then we get various different things each year but we get the pay
gap in the final column. Let us have a look at
the data by comparisons. So I am going to open
this one, nutrients. Now, we can see this
is quite different. Firstly, we have multiple items but also over the
years go across. Now we could, as
we previously did, manipulate the data to
make it fit our program. But in this case, we
got quite a lot of data and so I think
it's going to be easier to manipulate
the code to interpret the data correctly rather than the other way round and so that's what I am going to do. So let's take a look at
where our data is loaded in. So the first thing I
need to do in here with the pre-life function is to change the data path to
make it the correct file. So if I look, my real data is in food and
it's called nutrients74-16. So let's change this data path. The food and its
nutrients74-16.csv. The next thing I need
to do is I need to change what's going on in setup. So we've got a start year and originally we were
getting our start year by looking at the first
row in the item year. If we actually at our data, we don't have years set out
in that way but we do know that the year is in our second column so that
would be columnar index one. If I look p5 table, I can see that it has a
field called columns. So I could use that. So let me just show
you what I mean. I could Console Log
this at the moment. Most of the code won't work, but I can console log this. So I could go this.data.columns and I will just console.log. We can run this code. So we won't see anything there because there will be
a lot of problems, but if we look at that columns, we can see that we have got
item one is 1974 and so on. So that's great. I could say that start year is this.data.columns
at index one. You might also notice that
the type of this is a string, so we want to change
it to a number and we should have this in
our helper functions. I think we have
string to numbers. So I think I should be able to do that or actually
I will tell you what, I am not going to do it that way, I am going to just say
number like this and convert it to a number and I'm
going to get the end year. If I also look back
at my columns, I can see that the very last
item is just my end year. So my end year can
be data.columns at the index
this.data.columns.length minus one because that's how you get
the last item of an array. Likewise, I want to
convert it to a number. Great. So I've got a start
year and an end year, but there's still a lot
of other problems here. So I am going to leave
this part that involves min pay gap or max pay
gap at the moment. What I'm going to do
is, I'm going to go onto my drawing code. Now, if you remember
in the original graph, we only have a single
series, it's a plot. But in our current dataset, we have got lots of
different series. So we are going to need to take quite a different approach. So I have got this for loop
that goes through each row. What I am going to do is I'm
going to extract each row here and store it in a local variable which
I will call row. So this.data.getRow and we'll start with getting row
using the index i. Now, the next thing
I am going to do, so if you remember looking
back of this data, that will get us energy, and then protein, and calcium, and iron, and so on. But we need to know it's right
and go through each year. So I'm going to make a second for loop here. Here, we're going to go through
by the number of years. So I'd actually already got this calculated by getting
end year and start year, so I can go num years. I'll just make the loop and
then we'll copy and paste things in because it's a
little bit safer that way, we won't loose track
of our brackets. So the next thing I need to do is create this current object. You just do that again. So first of all, we need to
work out what the year is. So the year will be row.getNum, because we are going
to try and get some number out of it, and it will be at the position j but it
won't quite be j, will it? Because the first column
is actually the label. So it's j plus 1. That will get us the year. Now, pay gap isn't quite what
we're working with here. We're actually working
with percentages, so I'm going to call
this one percentage. We will get this by going row. I apologize, I have done this the wrong way around, haven't I? The percentage we'll get
with row.getNum j plus 1 and the year. In fact, I take
both of these back. We'll get it from getNum at rowj and we should just start with one because
that will make more sense. So that means we're
going to start here, then we're going to go here, then we're going to
go here and so on and we won't bother with
that first column. So we'll get that value
that for the year. This is actually easier. All we do is we start with this.startYear plus j. That's not going to quite work, either, that will give
us the wrong year. So I need to put plus j minus 1 to make that work out because we're starting
with column one. All right. So we have a year
and we have a percentage, and then we have
our drawing code. Looking at our drawing code, we could just cut and
paste that there. That will work. Finally, we have this
assigning that goes on where we assign the previous position now to
the next current position. We've copied all of that over. Now, this code still
won't probably work but we're pretty
close to it now. So what I might do is just have a look and see what's running
and what's not running. So we still have an error here, cannot read property
one of undefined in nutrient setup at line 73. So let's just have a quick
look at what's going on there. Is because I spelt
columns wrong, isn't it? It happens wise. Let's try again. So we can see our
years spread out, but we're not yet
seeing any data. So that's working quite well. So the next thing is we need
to set this values PayGap. This determine the
heights of the y-axis. Now, there's an easy cheaty
way to do it and a hard way. For the moment, I'm just going to use the easy cheaty way. So what I'm going to do is try
and look for where there's the minimum value here. I know that really the values go lower in the far columns. I can see 95, 94, 92, I think is lowest value. So I'm just going
to play it safe. I'm going to put 80
as my lowest value. Then I'm going to look for the highest value and I
think if I look here, I can see 302. Can I see anything
higher than that? Three hundred and twenty, 325, I think I will play
it safe and I'll pay 400. Now, it seems a shame to be
talking about PayGap here. That's not really what
we're working with. We're working with percentages. So I'm going to replace these. I'm going to minPayGap, and we'll do a replace
with minPercentage, and we'll do maxPayGap, and we'll do a replace
with percentage. Great. So hopefully now, we should perhaps see some data drawn to our
graph. Let's have a look. We're still not seeing
any data so but I can now see my
values on the axis. So let's have a look at why our series aren't
yet being drawn out. Perhaps what I'll do is just
check what's happening in terms of my objects here
as I iterate through. So I'm going to just do a console log and
we'll have a look. So I can see the years and
I can see the percentages. So that's definitely
working okay. Let's check if our drawing
code is actually happening. So we run again and
I'll select it again. Yes, my drawing
code is happening. I think I can see the problem, I'm not sure if you
can see it here. I just realized I'm still
referring to PayGap here. So we change these to percentage. So I need to put percentage
in each of these. Good. I think I have all of those and let's have a
look at what we have now. Great. So we can start to see our data but it's really messy. You might notice that there
are these long lines, they're somehow joining all
of these things together. That's because of this little
bit of code that says, if previous doesn't equal null. So here, we are storing the previous point to
draw the next point. That works when we draw a single series but if
we draw multiple series, you imagine you get to
the end of the series and you haven't create that
variable cool previous, it's going to go back
to the next one. So what I'm going to do is, instead of declaring
previous here, I'm going to declare it new for each row in our table and I'm going to initialize it
as null just to be safe. Let's refresh that
and see what happens. So that's already much better. Now, it would be nice if our different series were
also different colors. So I'm going to make an array of random colors to display this. So let's make something up here, this.colors, and we'll
initialize it to an empty array. In setup, once we know
the number of rows, which we can work out here, we can do a for loop. So it's this.data.getRowCount
is the method, and we can add a random
color to colors, this.colors.push and
we will add a color, small c, and we'll go random between zero
and 255 for red, green, and then blue. There's a random colors. Now, we can set the color
when we do the drawing. So we go stroke this.colors, and we need to make sure
we're doing this.colors i. So if I have a look now, I have different colors
for all my data. So that's great. The next thing is, I actually want to see what these different items
of data actually are. So I should really
write the text. So this is where I need to
get the label of the text. So here, I'm going to make a variable code L for label
and do row.getString. If we look back at our data, we can see that the first
column gives us that. So getString at column
zero.Then we can draw that at the very
beginning of our data. So where it says, if previous doesn't equal no, well, if it does equal no, that's our first item. So here, I can put text
and we've got L for label, that's perfect, and I can
put it as a position. I can put it at, let's see. We can work out the exposition by going mapPayGapToHeight.
Here we are. Not PayGaps or high
current percentage. So that will give me the
height to put it up and the x. Well, let's just put
it at position a 100, or maybe we need
to go noStroke for this and fill in block. Let's have a look at that. Actually, let's fill in our color because
we have a color. So we can fill in this.colors j, and we'll have a look back now. Okay, good. I think that my colors don't
seem to be working quite right there. Let's have a look. It's not colors j is colors i. That's why. Let's
have a go again. So now, we can see that this is vitamin A is decreasing
the intake over time, and the niacin has
stayed pretty equal, protein has declined here, and we can see that
vitamin C intake has actually risen
over the years. Now, there are lots of other
things that you might want to do to improve
this visualization, but I'm going to
leave those to you. So for example, you might want to get these
labels better placed, you might want to see if you can get less years
drawn because obviously, these are all overlapping
and hard to read. You might want to go back to the minimum and maximum
percentages and rather than doing it with an
IPL technique like I used, actually do it dynamically by
iterating through the data and finding the real
minimum and maximum values. But I'm going to leave
all of that work to you. So now it's your turn.
________________




Creating your journal
In this topic we have introduced you to the first of our extension ideas. Discuss the following aspects of their design.
* What do you need to do to integrate the extension with the template application?
* How might you enhance the extension with your own ideas?
* What challenges might you face implementing the extension?
Make sure you are clear which of the extensions you are interested in implementing in your response. If you haven't chosen which template you want to extend yet, you can talk about all three extensions and how they are influencing your decision.


________________


Week 11 - 6.101 Project progress check


In this topic, we will show you the second set of
application extensions. These will be a bit more complex than the
first extensions. To help you understand them, we will go into more detail
on their design and planning. Hopefully, you will
also be thinking about your own ideas and how to code
them into the application. If your ideas are quite
advanced at this stage, you could even start working
on designs and code demos. In this topic, we'll
introduce you to the midterm report and get you to start drafting out
the report sections. The midterm report is an opportunity for you
to get feedback on your ideas and establish
whether they are sufficient to meet the
requirements of the project. In addition, we want you to
produce a detailed plan for how you're going to divide out the time between now
and the deadline. We will help you with some
techniques for doing this. Finally, in this topic, there will also be another
student interview where one of our students from Goldsmiths
will show off their project.


________________


Over the next few videos, we're going to look at building an extension to the
data visualization app. The reason for
splitting this up into three videos is not because
it's hideously complex, just that it has a
few different moving parts and I want them to have the space to stand
on their own and hopefully make a more
organized reference for you. This extension is going
to involve the design of a survey instrument to gather data for creating our
next visualization. Survey design alone is a
topic that can fill a module. So we are only going to
scratch the surface in this video but it's a
good technique to learn and you'll be able to employ it not just for extensions to this app but also for validating the
usability of your apps. You may be thinking that
survey design doesn't sound a lot like
programming, and it's not. However, as programmers we
need to be able to apply ourselves to lots of skills and then apply
these in our code. We aren't going to go into
statistical detail on how surveys should be processed
or analyzed in this course, we are interested in how data is collected, processed,
and visualized. To summarize, a survey
is a collection of questions that we ask a sample
of a population to answer. When I talk about population, I can mean a country, uses of a particular app or consumers of a particular
variety of baked beans. The point here is that
we can't ask everyone, we have to select a sample of people that represent
the wider group. Surveys are useful because they are very quick and cheap to run. You can easily ask a
sample of hundreds or even thousands of people
to complete the survey, we have a relatively
small outline. You don't need to sit
with participants as they complete it, you can get them to
fill it in a distance. Contemporary surveys
are often completed online and I'll show you a
tool for dealing with shortly. The negative side of this
is that they aren't very good at getting
detailed information out to the respondents, you need to make sure you are asking the right questions in the correct way to get
good data from a survey. It's all too easy to put together a bad survey and very
difficult to write a good one. As such, you can
think of a survey as a good way to get an
overview of a topic, spot certain trends, and then use other methods for more
detailed analysis such as interviews, focus groups or user studies. Before we write our survey, we need to establish what it
is we're hoping to find out. Too often, a project
student will show me a draft survey that has been designed to give them
the answers they want, instead of getting
into the heart of what the population thinks or needs. Often, this is because they
have already determined the design direction in their own mind and they're
looking for confirmation. We'll also need to establish
who our population is and how are we going
to go about asking them. Let's take a look at the potential survey example
that you could investigate. This aim is an overview of a
surveys research question, but it neatly
encapsulates lots of information about what
we are looking into. Firstly, we are
looking for attitudes. So how do people feel about dogs that live in
high-rise apartments? What do they think
welfare issues might be? If any, for the
dogs or the people. Practice is asking
the respondents to consider how they
look after their dog. Obviously here
we're going to need to compare practice between high-rise dogs and those that live in other
types of house. So this is going to
affect our sampling. So let's break this down
into smaller objectives. To be honest, I've
done this is a bit of a thought experiment and its
limitation of the design. You will be better off
looking more deeply into this area and understanding
the potential challenges. For example, what
do welfare experts think the issues might
be and ask them those. You might be able to
find this out from newspaper articles
or charity websites. But for now, this will be good enough for our discussions. As I've said, we're going to
want to compare practices. So we should ask dog owners who live in different types of property about their dogs and
how they look after them. First let's find out how many dogs people own
and the breed of dog. The people in apartments
tend to have smaller dogs. We might want to know how
often the dogs walks. This could be a good metric
for understanding welfare. So we don't know that for sure. But if we see a difference, then we can perhaps look in
more detail at the agility, happiness or longevity of different dogs and make
more firm conclusions. Remember a survey is good
for getting an overview. Then we can look in more detail. A keyword here is perception. Often a survey is giving us a perception of what
a person thinks, not a statement of fact. Perhaps people with dogs in
high-rises don't believe their doctor clean or maybe
because of space limitations, they are more aware
of these issues and take more countermeasures. We also need to be careful
we don't offend anyone. So we have to be
careful how we pose this question to get a
good honest response. Every dog is important
to their families. Maybe this is a good opportunity for an open-ended question. Ask people to respond
with how their dog is parts of their lives
and their families. We can then categorize the things that respondents say and make assertions on the
differences between dog owners in high-rises
and other houses. We have already spoken a little about packing a sample
for our survey, but it's a very important
consideration to make sure we get relevant
and representative data. Say you've been asked to conduct a survey for a baked
bean manufacturer. The beans are bought by
300,000 people each week, and you only have
the resources to ask 2,000 people about how
much they liked the beans. You need to make sure you ask a wide sample of bean purchases. If you just ask young people, then you might get
an imbalanced view on the pricing structure. If you only ask people
from a certain community, they might find the beans
too bland or too spicy. So we need to make
sure our sampling is stratified to represent the
population in important ways. This could be age or gender, but could be who they last voted for in a political opinion poll, or the sector that
respondents work in for completing
employment surveys. Sometimes we may only want to ask questions of a certain cohort for example university students, where the age profile is skewed towards the lower demographic. Let's turn our attention to writing the questions themselves. We've already mentioned open ended questions
where the respondent is given a blank text field and are aimed to fill
in their own opinion. These are useful for getting more detail apps respondents and asking more
complex questions. But they do require
more analysis and can't easily be implemented
in a visualization. Along with open-ended questions, there are closed-ended questions. Questions where we
give the respondents a limited number of
options to respond with. These can either have ordered responses where there is some ranking to those responses such as the questions
on this graphic, they ask respondent to make
a decision on a scale. Other types of closed-ended
questions don't have a scale. The most simple of this type of question would be yes or no, but you may also
ask questions with several categories that
don't have a rank. Let's turn our attention to a concrete example that we will use to build on next extension to the data visualization app. So I've got here a survey which I've written
using Google Forms. Say you can sign up
for this for free. It's parts of the
Google Docs suite of applications and it allows you to create surveys
really quite easily. We'll be able to see
some of the theory that we've talked about and
how it works in practice. So if you gave two Google forms, you can just click blank
to create new survey. I've already got one here which I've written
some questions in about students eating behaviors. So how healthfully to they eat? What can we do to encourage
them to be more healthy? How often do they eat breakfast? How many fruit and
vegetables they eat? That kind of thing. So I've got some questions here, they're probably not the
greatest questions in the world and when you
write your surveys you can put a little bit more effort into thinking about what it is you're actually looking for and what you're
hoping to find out. So we can see here we've
got the first question, do you eat breakfast? This is one of those
closed-ended questions. So the users can add
their respondents. Can only put in a few different possible answers, yes or no. That doesn't have
any form of order. But the next question, which is how many portions
of fruit and vegetables do you eat each day on average, and we've got here a ranking. So they can put in between 0, 1, 2, 3, 4, 5 or more than 5. In fact, there's a
little mistake here. Actually this is something
you have to watch. Because you can see here
I've got five and five plus. So if you eat exactly five, which one of these three
boxes are you going to take? So we want to make
this a little bit clearer and make that six plus. So very easy to add extra
options in Google forms. You can just click
here to add an option, click on them to
change things round, and that's our
questions are done. This question has a little
bit more complicated. I've got a grid of
possible responses. Because what I want users to do, and this is the thing
that we're going build our extension out of this
particular question, is to say what they did
for their evening meal for each day of the last week
whether they didn't eat, whether they had a takeaway, they ate out and this has cooked from fresh which you can't quite
see all of that, whether they had ready meal or whether they ate leftovers. So hopefully that gives
us the full gametes and things that people
might do for dinner. But I might have missed
something out there. We possibly should have
another box as well. I used the word dinner
there carefully, because for those of you
that are from the UK and I'm sure this is similar in other parts of the
English-speaking world, different people
call their evening meal different things. So some people call it dinner, some people call it tea, some people might call it supper. So I've used the
phrase evening meal to be really clear about that, because some people would
have their dinner in the middle of the day and other people who have a
dinner at the end of the day. So you got to watch out and
think about these things. How are people going to interpret these questions and make
sure it's absolutely clear. Okay. So few more questions. Again, another scale here about how much people spend on food. Describe your favorite foods. So this is one of our
open-ended questions and the user can type in
however much they want. Then we've got
another scale here. This is called the Likert scale. So we are saying,
"Do you consider yourself to have healthy diet?" One, two, three, four or five. People can pick where on that
scale they think they are. We've got here not very healthy at one end and
healthy at the other. We have to make
this really clear. Because one person will interpret
it the wrong way round. They will get these boxes upside down and they will put one because they think
they're really healthy. Not five. Just always happens. Also, be a little
bit careful about being absolutist when you
put these selections in, because people tend not
to pick the very edges. So they're not going
to say, "Oh, yes. I have the most healthy
diet possible." Very healthy is a
good compromise. Then obviously
you've got healthy. Neither. Okay. Not very healthy. Then very unhealthy at the end. We need some
demographic questions to make sure that we have a good sample and that we
are stratifying our results. So I'm asking which year of
University are people in. So Foundation year, year one, year two, year
three, masters, PhD. That should just about cover all the students who are
going to fill this in. Then the final question, last but one question, is to ask people what
gender they are. It's really important
here that we have a box for people to say, "Actually I don't want to
tell you what gender I am or that I'm some other gender that doesn't fit into
either these boxes." We give them the option to
be able to fill that in. Then, finally, again,
we've got age here. For demographic
reasons, we might be interested and see what by the mature students do
slightly different behaviors, the students who have
families who maybe don't fit the classic model of someone who's just left school and then
gone on to university. Most like many of you
people watching this video. So that's the rough
outline of our survey. Obviously, there are
more interesting questions that we
could put in here. This is just a start point. We just have a look at
adding an extra question. So we need to take
away from that. We just click "Add
Question" here. I want this put it in the
middle point. Oh there we go. So this allows us to
choose what it is we are going to ask the
user to respond with. So short answers, longer
paragraphs, multiple choice. So that would be like
this question for the, which year of university your in. Checkboxes, which
would allow them to select multiple answers. Drop-down menu, so they can
select one from a list. They can apply to file. Then we've got this linear scale. So that's like the Likert scale. The multi-choice grid. That's what I had for the
days of the week matrix. Okay. So when we
finished our survey, we can preview it. Sorry.
Wrong button there. We can preview it and
see what it looks like to the people who
will be responding. The other really
important thing is, once we sent this out, so we can use the same button, send it to as many
people as possible. We can then download
the responses. So we can either open it up inside the spreadsheet
in Google docs, or more usefully for us, we can download the
responses as a CSV. That's how you're going
to get the data out of Google forms and
into your p5 sketch. So let's have a look at
what that downloads. So let's download responses. Now, no one has
completed the survey. So it's not going to
be too interesting. So let's just open that up. So no one's completed this yet. You can see here we've
just got the headings. These are really
long and unwieldy. So the first thing we
want to do probably when we download this
is to put nice short, little camelcased or underscored names for each of these columns. Because remember we can
use those in our program. We don't want to be
typing in "what did you have for your evening meal
each day last week? " every time we want to
access this column. So you can see here, I've got exactly that. Where I've taken the
data from the survey, shortened these names
and I've got all about, how many responses I've got? Three hundred I think. Yeah.
I have just a 300 responses. I've not actually gone out and got people
to fill this in. I've cheated and I've written
a program to fill this in. You see here with
these long responses, the favorite food and what might encourage you to
have a healthy diet. I have not filled those in, I've just left them blank
with a placeholder. A bit of a cheat. Now, you have to be very careful if you choose
to cheat like this. Because falsifying results is actually a form of
academic misconduct. It's a bit like plagiarism. So the best thing to do is
to put your survey out, get people to fill it
in and use real data. Then when you do
your visualizations, you'll actually be able to see interesting things in them, not just pretty colors and things that look
like visualization. They'll actually be
weight to that data. But there is some effort in doing that and you might not have time. So if you do choose
to produce the data, make sure you make
it really clear on your report that
that's what you've done. If you've used a bit of
code to help you do that, you can include that
in your submission and you might get a
few marks for it. But only do this if you make it clear that's
what you've done. So that's that, a big
warning and a caveat that. What might find if you have
done this for reals though, is that you might have
some missing data. So someone might not have
responded to all the boxes. They might miss
the questionnaire, and you may have to
make a decision, what do you do with
that piece of data? So it might be you say, "Okay." So hypothetically this line here, 34 has missed out some data. You might say, "Okay.
I'm just going to remove it from my data
set and not use it." Or you might try and make
a guess for what they've put in for the piece
of missing data. So you might average all of that column and put in
the average for that one. So that and you can still use the other data that
they provided you with, but you have to make a decision
on what you're going to do and do it systematically. So in the next video, we're not actually going
to start coding just yet, we're going to build a
outline of this app. We're going to do a
diagram as we've seen with the case study templates. We're going to
understand a little bit about how it's structured. Then we'll get into actually
writing the code for it.
________________


Week 11 - 6.204 Extending the data visualiser: gathering and collating survey data


Over the next few videos, we're going to look at building an extension to the
data visualization app. The reason for
splitting this up into three videos is not because
it's hideously complex, just that it has a
few different moving parts and I want them to have the space to stand
on their own and hopefully make a more
organized reference for you. This extension is going
to involve the design of a survey instrument to gather data for creating our
next visualization. Survey design alone is a
topic that can fill a module. So we are only going to
scratch the surface in this video but it's a
good technique to learn and you'll be able to employ it not just for extensions to this app but also for validating the
usability of your apps. You may be thinking that
survey design doesn't sound a lot like
programming, and it's not. However, as programmers we
need to be able to apply ourselves to lots of skills and then apply
these in our code. We aren't going to go into
statistical detail on how surveys should be processed
or analyzed in this course, we are interested in how data is collected, processed,
and visualized. To summarize, a survey
is a collection of questions that we ask a sample
of a population to answer. When I talk about population, I can mean a country, uses of a particular app or consumers of a particular
variety of baked beans. The point here is that
we can't ask everyone, we have to select a sample of people that represent
the wider group. Surveys are useful because they are very quick and cheap to run. You can easily ask a
sample of hundreds or even thousands of people
to complete the survey, we have a relatively
small outline. You don't need to sit
with participants as they complete it, you can get them to
fill it in a distance. Contemporary surveys
are often completed online and I'll show you a
tool for dealing with shortly. The negative side of this
is that they aren't very good at getting
detailed information out to the respondents, you need to make sure you are asking the right questions in the correct way to get
good data from a survey. It's all too easy to put together a bad survey and very
difficult to write a good one. As such, you can
think of a survey as a good way to get an
overview of a topic, spot certain trends, and then use other methods for more
detailed analysis such as interviews, focus groups or user studies. Before we write our survey, we need to establish what it
is we're hoping to find out. Too often, a project
student will show me a draft survey that has been designed to give them
the answers they want, instead of getting
into the heart of what the population thinks or needs. Often, this is because they
have already determined the design direction in their own mind and they're
looking for confirmation. We'll also need to establish
who our population is and how are we going
to go about asking them. Let's take a look at the potential survey example
that you could investigate. This aim is an overview of a
surveys research question, but it neatly
encapsulates lots of information about what
we are looking into. Firstly, we are
looking for attitudes. So how do people feel about dogs that live in
high-rise apartments? What do they think
welfare issues might be? If any, for the
dogs or the people. Practice is asking
the respondents to consider how they
look after their dog. Obviously here
we're going to need to compare practice between high-rise dogs and those that live in other
types of house. So this is going to
affect our sampling. So let's break this down
into smaller objectives. To be honest, I've
done this is a bit of a thought experiment and its
limitation of the design. You will be better off
looking more deeply into this area and understanding
the potential challenges. For example, what
do welfare experts think the issues might
be and ask them those. You might be able to
find this out from newspaper articles
or charity websites. But for now, this will be good enough for our discussions. As I've said, we're going to
want to compare practices. So we should ask dog owners who live in different types of property about their dogs and
how they look after them. First let's find out how many dogs people own
and the breed of dog. The people in apartments
tend to have smaller dogs. We might want to know how
often the dogs walks. This could be a good metric
for understanding welfare. So we don't know that for sure. But if we see a difference, then we can perhaps look in
more detail at the agility, happiness or longevity of different dogs and make
more firm conclusions. Remember a survey is good
for getting an overview. Then we can look in more detail. A keyword here is perception. Often a survey is giving us a perception of what
a person thinks, not a statement of fact. Perhaps people with dogs in
high-rises don't believe their doctor clean or maybe
because of space limitations, they are more aware
of these issues and take more countermeasures. We also need to be careful
we don't offend anyone. So we have to be
careful how we pose this question to get a
good honest response. Every dog is important
to their families. Maybe this is a good opportunity for an open-ended question. Ask people to respond
with how their dog is parts of their lives
and their families. We can then categorize the things that respondents say and make assertions on the
differences between dog owners in high-rises
and other houses. We have already spoken a little about packing a sample
for our survey, but it's a very important
consideration to make sure we get relevant
and representative data. Say you've been asked to conduct a survey for a baked
bean manufacturer. The beans are bought by
300,000 people each week, and you only have
the resources to ask 2,000 people about how
much they liked the beans. You need to make sure you ask a wide sample of bean purchases. If you just ask young people, then you might get
an imbalanced view on the pricing structure. If you only ask people
from a certain community, they might find the beans
too bland or too spicy. So we need to make
sure our sampling is stratified to represent the
population in important ways. This could be age or gender, but could be who they last voted for in a political opinion poll, or the sector that
respondents work in for completing
employment surveys. Sometimes we may only want to ask questions of a certain cohort for example university students, where the age profile is skewed towards the lower demographic. Let's turn our attention to writing the questions themselves. We've already mentioned open ended questions
where the respondent is given a blank text field and are aimed to fill
in their own opinion. These are useful for getting more detail apps respondents and asking more
complex questions. But they do require
more analysis and can't easily be implemented
in a visualization. Along with open-ended questions, there are closed-ended questions. Questions where we
give the respondents a limited number of
options to respond with. These can either have ordered responses where there is some ranking to those responses such as the questions
on this graphic, they ask respondent to make
a decision on a scale. Other types of closed-ended
questions don't have a scale. The most simple of this type of question would be yes or no, but you may also
ask questions with several categories that
don't have a rank. Let's turn our attention to a concrete example that we will use to build on next extension to the data visualization app. So I've got here a survey which I've written
using Google Forms. Say you can sign up
for this for free. It's parts of the
Google Docs suite of applications and it allows you to create surveys
really quite easily. We'll be able to see
some of the theory that we've talked about and
how it works in practice. So if you gave two Google forms, you can just click blank
to create new survey. I've already got one here which I've written
some questions in about students eating behaviors. So how healthfully to they eat? What can we do to encourage
them to be more healthy? How often do they eat breakfast? How many fruit and
vegetables they eat? That kind of thing. So I've got some questions here, they're probably not the
greatest questions in the world and when you
write your surveys you can put a little bit more effort into thinking about what it is you're actually looking for and what you're
hoping to find out. So we can see here we've
got the first question, do you eat breakfast? This is one of those
closed-ended questions. So the users can add
their respondents. Can only put in a few different possible answers, yes or no. That doesn't have
any form of order. But the next question, which is how many portions
of fruit and vegetables do you eat each day on average, and we've got here a ranking. So they can put in between 0, 1, 2, 3, 4, 5 or more than 5. In fact, there's a
little mistake here. Actually this is something
you have to watch. Because you can see here
I've got five and five plus. So if you eat exactly five, which one of these three
boxes are you going to take? So we want to make
this a little bit clearer and make that six plus. So very easy to add extra
options in Google forms. You can just click
here to add an option, click on them to
change things round, and that's our
questions are done. This question has a little
bit more complicated. I've got a grid of
possible responses. Because what I want users to do, and this is the thing
that we're going build our extension out of this
particular question, is to say what they did
for their evening meal for each day of the last week
whether they didn't eat, whether they had a takeaway, they ate out and this has cooked from fresh which you can't quite
see all of that, whether they had ready meal or whether they ate leftovers. So hopefully that gives
us the full gametes and things that people
might do for dinner. But I might have missed
something out there. We possibly should have
another box as well. I used the word dinner
there carefully, because for those of you
that are from the UK and I'm sure this is similar in other parts of the
English-speaking world, different people
call their evening meal different things. So some people call it dinner, some people call it tea, some people might call it supper. So I've used the
phrase evening meal to be really clear about that, because some people would
have their dinner in the middle of the day and other people who have a
dinner at the end of the day. So you got to watch out and
think about these things. How are people going to interpret these questions and make
sure it's absolutely clear. Okay. So few more questions. Again, another scale here about how much people spend on food. Describe your favorite foods. So this is one of our
open-ended questions and the user can type in
however much they want. Then we've got
another scale here. This is called the Likert scale. So we are saying,
"Do you consider yourself to have healthy diet?" One, two, three, four or five. People can pick where on that
scale they think they are. We've got here not very healthy at one end and
healthy at the other. We have to make
this really clear. Because one person will interpret
it the wrong way round. They will get these boxes upside down and they will put one because they think
they're really healthy. Not five. Just always happens. Also, be a little
bit careful about being absolutist when you
put these selections in, because people tend not
to pick the very edges. So they're not going
to say, "Oh, yes. I have the most healthy
diet possible." Very healthy is a
good compromise. Then obviously
you've got healthy. Neither. Okay. Not very healthy. Then very unhealthy at the end. We need some
demographic questions to make sure that we have a good sample and that we
are stratifying our results. So I'm asking which year of
University are people in. So Foundation year, year one, year two, year
three, masters, PhD. That should just about cover all the students who are
going to fill this in. Then the final question, last but one question, is to ask people what
gender they are. It's really important
here that we have a box for people to say, "Actually I don't want to
tell you what gender I am or that I'm some other gender that doesn't fit into
either these boxes." We give them the option to
be able to fill that in. Then, finally, again,
we've got age here. For demographic
reasons, we might be interested and see what by the mature students do
slightly different behaviors, the students who have
families who maybe don't fit the classic model of someone who's just left school and then
gone on to university. Most like many of you
people watching this video. So that's the rough
outline of our survey. Obviously, there are
more interesting questions that we
could put in here. This is just a start point. We just have a look at
adding an extra question. So we need to take
away from that. We just click "Add
Question" here. I want this put it in the
middle point. Oh there we go. So this allows us to
choose what it is we are going to ask the
user to respond with. So short answers, longer
paragraphs, multiple choice. So that would be like
this question for the, which year of university your in. Checkboxes, which
would allow them to select multiple answers. Drop-down menu, so they can
select one from a list. They can apply to file. Then we've got this linear scale. So that's like the Likert scale. The multi-choice grid. That's what I had for the
days of the week matrix. Okay. So when we
finished our survey, we can preview it. Sorry.
Wrong button there. We can preview it and
see what it looks like to the people who
will be responding. The other really
important thing is, once we sent this out, so we can use the same button, send it to as many
people as possible. We can then download
the responses. So we can either open it up inside the spreadsheet
in Google docs, or more usefully for us, we can download the
responses as a CSV. That's how you're going
to get the data out of Google forms and
into your p5 sketch. So let's have a look at
what that downloads. So let's download responses. Now, no one has
completed the survey. So it's not going to
be too interesting. So let's just open that up. So no one's completed this yet. You can see here we've
just got the headings. These are really
long and unwieldy. So the first thing we
want to do probably when we download this
is to put nice short, little camelcased or underscored names for each of these columns. Because remember we can
use those in our program. We don't want to be
typing in "what did you have for your evening meal
each day last week? " every time we want to
access this column. So you can see here, I've got exactly that. Where I've taken the
data from the survey, shortened these names
and I've got all about, how many responses I've got? Three hundred I think. Yeah.
I have just a 300 responses. I've not actually gone out and got people
to fill this in. I've cheated and I've written
a program to fill this in. You see here with
these long responses, the favorite food and what might encourage you to
have a healthy diet. I have not filled those in, I've just left them blank
with a placeholder. A bit of a cheat. Now, you have to be very careful if you choose
to cheat like this. Because falsifying results is actually a form of
academic misconduct. It's a bit like plagiarism. So the best thing to do is
to put your survey out, get people to fill it
in and use real data. Then when you do
your visualizations, you'll actually be able to see interesting things in them, not just pretty colors and things that look
like visualization. They'll actually be
weight to that data. But there is some effort in doing that and you might not have time. So if you do choose
to produce the data, make sure you make
it really clear on your report that
that's what you've done. If you've used a bit of
code to help you do that, you can include that
in your submission and you might get a
few marks for it. But only do this if you make it clear that's
what you've done. So that's that, a big
warning and a caveat that. What might find if you have
done this for reals though, is that you might have
some missing data. So someone might not have
responded to all the boxes. They might miss
the questionnaire, and you may have to
make a decision, what do you do with
that piece of data? So it might be you say, "Okay." So hypothetically this line here, 34 has missed out some data. You might say, "Okay.
I'm just going to remove it from my data
set and not use it." Or you might try and make
a guess for what they've put in for the piece
of missing data. So you might average all of that column and put in
the average for that one. So that and you can still use the other data that
they provided you with, but you have to make a decision
on what you're going to do and do it systematically. So in the next video, we're not actually going
to start coding just yet, we're going to build a
outline of this app. We're going to do a
diagram as we've seen with the case study templates. We're going to
understand a little bit about how it's structured. Then we'll get into actually
writing the code for it.
________________


Week 11 - 6.205 Extending the data visualiser: sketching the waffle charts code
0:00/13:56
* 

Transcript
Interactive Transcript - Enable basic transcript mode by pressing the escape key
You may navigate through the transcript using tab. To save a note for a section of text press ⌘ + S. To expand your selection you may use ⌘ + arrow key. You may contract your selection using shift + ⌘ + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using ⌘ in conjunction with the alt key
So from the last video,
we have got all data collected to
build our next extension for the data visualization app.
So you may remember that we had a series
of questions that we
asked students about their eating behaviors.
One of the things we asked them to do was
to tell us what they
ate each day during the previous week,
so for their evening meal,
and we've got this data saved in CSV file,
and I've got that CSV file open here.
It's this question that we're going to use
to build our next visualization with.
So you can see here,
that on Monday, the first student had a takeaway.
On the next day, they cooked
a meal from fresh and then they ate out.
So what we're going to create is
a series of waffle charts.
So waffle charts look like this.
They are grids which we've programmed before.
We remember how to do them with loops nested
within side each other and we've got here colored grids,
and when we hover ever,
it would tell us exactly what
the proportion of students ate for that day,
whether they ate in, whether they had a takeaway.
So each of these seven,
I haven't labeled this very well,
but that's Monday, Tuesday, Wednesday,
Thursday, Friday, Saturday, and Sunday.
Just look at this diagram,
you can see that students tend to cook
food for themselves during
the week and most of them cook them fresh,
some may eat ready meals,
some maybe ate out.
But then this changes is at the weekend.
So we've look here at Saturday and Sunday,
lots of students have takeaways,
fewer did their own cooking and quite a lot eat out.
So kind of what you'd expect to see,
that's probably because made up this data.
But it chose quite a simple visualization like this,
we can actually infer quite a lot meaning from it.
So rather than going straight into the code,
what I wanted today was spend a little bit of
time actually designing out and
sketching out what this paragraph is going to
look like and this is,
in fact, almost exactly what I
did to work on how to build it.
So I'm just replicating the process that I followed.
So if we take a look at the drawing with our staff today,
we're going to have
an HTML file and that's going to build a P5 app.
So remember we are not putting this into
the context of the template,
I'm going to do it separately and
then part of your job
would be to put this into that template.
So you can see here that I've written out the HTML file,
the P5 app and we've got to dependency here for P5.js.
So very standard application
starting exactly as we'd expect.
So what do we need to do to get this together?
Well, the first thing we're going to have to do,
is load in some data.
So let's pull out this app a global.
So we're using the same process
that we used before here for
a diagram that's not very formal but it's
just going to help us to build up our application.
This is going to be our data.
So let's hotline for that box.
What is our data?
Well, it is a P5 table, sorry P5.table.
That's how we're going to store
the data from the CSV file.
So if we just put under here, data.csv.
So we're going to load that and
we going to have a table of data.
Then the other thing we're going to have,
another global, it's going to be our series of waffles.
So we're going to use a constructor function to
build up seven waffles.
So we don't want to be writing out
the code again and again,
so we're going to use a constructor function.
So the waffles are going to take the data from the table,
they're going to take the data from this table.
Try and pick the right tool.
That's going to populate each of these little charts.
So let's start thinking about what
these waffle construct is going to look like.
So let's start building
up a constructor here and we'll call it
waffle and we're going to
need some properties in our waffle.
Some of them are going to be private
and some of them will be public.
So what we need.
Well, we need the data,
but we only are interested in one column for each waffle.
So Monday is going to be a waffle,
Tuesdays is going to be a waffle.
That's represented by one column in our data.
So let's call this table underscore column.
So we're going to need to store that.
The other thing that we're going to need is going
to be an x and a y.
So these are all private variables up here.
We're not going to need to share
these with other parts of our program.
So then we've got our heights and our width.
So this is just the basic principles,
how big are we going to display this on screen.
But as well as having the physical width in pixels,
we also needs to know how many boxes are
we going to have because we could change this.
So my original version,
I've got 10 by 10 but we can make that bigger,
we could make it smaller,
we could choose whatever we like.
So as well as having a height and a width,
we also need to know how many boxes
across and how many boxes down.
So all these values are going to come from
our parameters for this constructor function.
What else do we need?
So we're going to want to actually
have probably an array of boxes.
So let's have that as well.
So boxes and I'm going to put an array symbol next to it.
Now, this is actually going to
be a two-dimensional array.
So we're going to have an array of arrays.
So if I put another box
or another set of brackets next to it,
then we'll know that's what that is.
What else we're going to need? We're going to
need some colors too.
So that's almost there.
The only other thing we need of of
course is the categories.
So each different color
of box is going to be a different category.
So we need to know what those categories are.
Now, I think we can get away with
categories even though a category
is going to have a color,
it's going to have how many boxes are in it.
I think we can get away,
rather than having a new construct here,
just having a literal because we're
not going to be doing much processing
with these categories.
So I can show that just with
a little set of curly braces next to it.
That colors, that's also
an array because that's what we're going to select
our colors from for which
one's going to be which in the diagram.
So that's all our privates properties.
We are going to need to have some methods as well.
So we're going to want to be able to add categories.
Now, I think the way to do this,
so when this waffle constructor is
created or a new object is created from it,
we're just going to want to call
a function called add categories.
Now, we can do this all
internally within the claw, add constructor.
We don't need to make this public as well.
So let's have this as private.
So adds categories.
So quite a lot going on.
We've got quite a lot of private lenders,
be them properties or methods,
but I think we're just about there.
So then when we want to draw this to the screen,
that's going to be when we going to want to
have a public method.
So we're going to call a method,
sorry, and will call it draw, so draw.
That's a method.
I'm just telling that is methods.
So that's pretty much it for our waffle.
Now, if you remember,
we had a member here.
In fact, I'm just going to highlight these
a little bit so we can see.
So we had these boxes member
and we're going to fill this with a series of boxes.
Now each one of those is going to have a screen location,
is going to have a color.
If you look back at my original implementation here,
you can see that it also,
as I highlight over the boxes,
it's going to show us a little label as to
whether that's been selected or not.
So we're going to need to have
another box constructor or a constructor for boxes.
So let's add that.
Let's color these all in first.
Nice and neat.
So all our private methods are colored in blue.
Let's create this box as constructor.
Then this can be quite a bit simpler.
So this is going to be called box.
What's a box got?
Well, it's got some private members
which are going to be it's x,
it's y, its width, and its height.
I'm running out of space,
so I'm going to just tighten things up.
Also we need to know what category it is too.
So each box, is going to have a category and
that's how it's going to know what it's label is.
So let's have a category there.
That's it for privates.
Let's add in a public member or two.
So we're going to have a draw function.
So each waffle draw is going to call all the boxes draws.
So a draw in setup will be called and
then that will call draw in
waffle and then that will call the draw in box.
That's what's actually going to draw
that rectangle to the screen.
So we're going to have a draw function here.
We're also going to do a check
whether the mouse is over as well.
So mouse over, both of these are functions.
So let's just finish that there.
We are right on the edge. That's good.
So we're going to say, add categories.
That's going to fill boxes.
Just leave it like that because
I'm running out of space there.
I'm highlighting that.
So we're almost there.
The only thing we have I've forgotten here is that we
also need to check for
the mouse clicks in the waffle as well.
So let's call
that check mouse.
So we probably haven't got this perfect yet.
We need to draw a line there, Say, fill waffles.
This probably isn't perfect,
we will probably come back and
discover that we've missed things out
or their are little things that we maybe
need change as things develop.
But it's given us a really good start to
get thinking about unbuilding this extension.
So the first thing we can do in code,
is we can go through and we can add in
all these properties and
methods that we've created and that will get us moving.
So in the next video,
that's exactly what we're going to do,
we're going to put this diagram into code.




________________


So from the last video, we have got all data collected to build our next extension for
the data visualization app. So you may remember
that we had a series of questions that we asked students about
their eating behaviors. One of the things we
asked them to do was to tell us what they ate each day during
the previous week, so for their evening meal, and we've got this data
saved in CSV file, and I've got that
CSV file open here. It's this question that
we're going to use to build our next
visualization with. So you can see here, that on Monday, the first
student had a takeaway. On the next day, they cooked a meal from fresh and
then they ate out. So what we're going to create is a series of waffle charts. So waffle charts look like this. They are grids which
we've programmed before. We remember how to do
them with loops nested within side each other and
we've got here colored grids, and when we hover ever, it would tell us exactly what the proportion of students
ate for that day, whether they ate in, whether
they had a takeaway. So each of these seven, I haven't labeled this very well, but that's Monday,
Tuesday, Wednesday, Thursday, Friday,
Saturday, and Sunday. Just look at this diagram, you can see that
students tend to cook food for themselves during the week and most of
them cook them fresh, some may eat ready meals, some maybe ate out. But then this changes
is at the weekend. So we've look here at
Saturday and Sunday, lots of students have takeaways, fewer did their own cooking
and quite a lot eat out. So kind of what
you'd expect to see, that's probably because
made up this data. But it chose quite a simple
visualization like this, we can actually infer quite
a lot meaning from it. So rather than going
straight into the code, what I wanted today was
spend a little bit of time actually designing out and sketching out what this
paragraph is going to look like and this is, in fact, almost exactly what I did to work on how to build it. So I'm just replicating the
process that I followed. So if we take a look at the
drawing with our staff today, we're going to have an HTML file and that's
going to build a P5 app. So remember we are
not putting this into the context of the template, I'm going to do it separately and then part of your job would be to put this
into that template. So you can see here that I've
written out the HTML file, the P5 app and we've got to
dependency here for P5.js. So very standard application starting exactly as we'd expect. So what do we need to do
to get this together? Well, the first thing
we're going to have to do, is load in some data. So let's pull out
this app a global. So we're using the same process that we used before here for a diagram that's not
very formal but it's just going to help us to
build up our application. This is going to be our data. So let's hotline for that box. What is our data? Well, it is a P5
table, sorry P5.table. That's how we're going to store the data from the CSV file. So if we just put
under here, data.csv. So we're going to load that and we going to have a table of data. Then the other thing
we're going to have, another global, it's going
to be our series of waffles. So we're going to use a
constructor function to build up seven waffles. So we don't want
to be writing out the code again and again, so we're going to use a
constructor function. So the waffles are going to
take the data from the table, they're going to take the
data from this table. Try and pick the right tool. That's going to populate
each of these little charts. So let's start
thinking about what these waffle construct
is going to look like. So let's start building up a constructor here
and we'll call it waffle and we're going to need some properties
in our waffle. Some of them are
going to be private and some of them will be public. So what we need. Well, we need the data, but we only are interested in
one column for each waffle. So Monday is going
to be a waffle, Tuesdays is going to be a waffle. That's represented by
one column in our data. So let's call this table
underscore column. So we're going to
need to store that. The other thing that we're
going to need is going to be an x and a y. So these are all private
variables up here. We're not going to need to share these with other
parts of our program. So then we've got our
heights and our width. So this is just the
basic principles, how big are we going to
display this on screen. But as well as having the
physical width in pixels, we also needs to know
how many boxes are we going to have because
we could change this. So my original version, I've got 10 by 10 but we
can make that bigger, we could make it smaller, we could choose whatever we like. So as well as having
a height and a width, we also need to
know how many boxes across and how many boxes down. So all these values
are going to come from our parameters for this
constructor function. What else do we need? So we're going to
want to actually have probably an array of boxes. So let's have that as well. So boxes and I'm going to put
an array symbol next to it. Now, this is actually going to be a two-dimensional array. So we're going to have
an array of arrays. So if I put another box or another set of
brackets next to it, then we'll know
that's what that is. What else we're going
to need? We're going to need some colors too. So that's almost there. The only other
thing we need of of course is the categories. So each different color of box is going to be
a different category. So we need to know what
those categories are. Now, I think we can get away with categories even though a category is going to have a color, it's going to have how
many boxes are in it. I think we can get away, rather than having a
new construct here, just having a literal
because we're not going to be doing
much processing with these categories. So I can show that just with a little set of curly
braces next to it. That colors, that's also an array because that's
what we're going to select our colors from for which one's going to be
which in the diagram. So that's all our
privates properties. We are going to need to
have some methods as well. So we're going to want to
be able to add categories. Now, I think the way to do this, so when this waffle
constructor is created or a new object
is created from it, we're just going to want to call a function called add categories. Now, we can do this all internally within the
claw, add constructor. We don't need to make
this public as well. So let's have this as private. So adds categories. So quite a lot going on. We've got quite a lot
of private lenders, be them properties or methods, but I think we're
just about there. So then when we want to
draw this to the screen, that's going to be when
we going to want to have a public method. So we're going to call a method, sorry, and will call
it draw, so draw. That's a method. I'm just telling that is methods. So that's pretty much
it for our waffle. Now, if you remember, we had a member here. In fact, I'm just going
to highlight these a little bit so we can see. So we had these boxes member and we're going to fill this
with a series of boxes. Now each one of those is going
to have a screen location, is going to have a color. If you look back at my
original implementation here, you can see that it also, as I highlight over the boxes, it's going to show us
a little label as to whether that's been
selected or not. So we're going to need to have another box constructor or
a constructor for boxes. So let's add that. Let's color these all in first. Nice and neat. So all our private methods
are colored in blue. Let's create this
box as constructor. Then this can be
quite a bit simpler. So this is going
to be called box. What's a box got? Well, it's got some
private members which are going to be it's x, it's y, its width,
and its height. I'm running out of space, so I'm going to just
tighten things up. Also we need to know
what category it is too. So each box, is going
to have a category and that's how it's going to
know what it's label is. So let's have a category there. That's it for privates. Let's add in a public
member or two. So we're going to
have a draw function. So each waffle draw is going
to call all the boxes draws. So a draw in setup
will be called and then that will call draw in waffle and then that will
call the draw in box. That's what's actually
going to draw that rectangle to the screen. So we're going to have
a draw function here. We're also going to do a check whether the mouse
is over as well. So mouse over, both of
these are functions. So let's just finish that there. We are right on the
edge. That's good. So we're going to
say, add categories. That's going to fill boxes. Just leave it like that because I'm running out of space there. I'm highlighting that. So we're almost there. The only thing we have I've
forgotten here is that we also need to check for the mouse clicks in
the waffle as well. So let's call that check mouse. So we probably haven't
got this perfect yet. We need to draw a line
there, Say, fill waffles. This probably isn't perfect, we will probably come back and discover that we've
missed things out or their are little
things that we maybe need change as things develop. But it's given us a
really good start to get thinking about
unbuilding this extension. So the first thing
we can do in code, is we can go through
and we can add in all these properties and methods that we've created
and that will get us moving. So in the next video, that's exactly what
we're going to do, we're going to put this
diagram into code.
________________


Week 11 -  6.206 Extending the data visualiser: building the waffle charts


We've got to the final
part of our trilogy on data collecting
and using surveys. So if you remember back
to the first video, we talked about how to run a
survey, collect some data, and then in the
last video we went through a coding diagram for the extension that we're going to build to the
data visualization app. So now we've done that, we can actually get on with
coding this app for real. So I've got the
starter sketch here and in here we have already
loaded in the data, so we've used that
load table function. I've also got a
couple of arrays in my setup function,
one called Days, so that's going to be each of the seven waffle charts that we're going to
draw to the screen. We've got another array
here of values which is the values that users could provide back for
those various columns. So we've got take away, cooked from fresh,
ready meal, ate out, skipped meal, left
overs, so whatever they ate for that day's evening meal. So that's what we've got so far. Now, let's start to
build up the code, and if you go back
to that diagram, maybe follow along as
we talk through it, that might help you a little bit. So we've got to create a couple of new
constructor functions. So let's go File, New and function box and if you look back
on that diagram, we want to take an x or y, width and height and
also the category. So the box constructor is here for each individual
cell of that waffle diagram, and then we will use those to populate the actual
waffle itself. So we've got our
function box and we have a couple of
functions that we need to add, so this.draw. So that's what's actually
going to draw out our waffle and then we've got this.mouseOver, its function. I've missed the equals function. I think we should parse a
mouseX and mouseY here. Now, you can make an argument, these global variables, why
parse them as arguments? It's a bit of a waste
but I think it makes the code more readable and cleaner as well as actually do. So that's the outline. I do still want to put in here, put a var x is equal to x. Now this is, again, is a little unnecessary because we've got these
arguments already, but it just keeps the code
bit neater, bit cleaner, whoever comes and uses this code will understand
what these things are doing. So var x, var y, var height, and var width. I'm also going to make
this.category, equal to category. You might think initially that doesn't make sense as
having that one as a public member that other parts of the program
can access but there's a little bug in the
code that we'll see later on where this is
going to help us out. So that's a bit of a heads up and we'll look at
that in detail later, and we can do most
things here because we know that we want to draw this out and we want it to
be the categories color. So category will have a thing in it called color
when we've written it and we'll set the fill to that and then we just need
to draw a rectangle x, y with width and height. Let's leave mail saver for a moment because we're getting
a bit too abstract here, we need to fill in
those other details so everything makes sense. Create the waffle itself and then category
will make sense. So let's give this a name, so this is going to be box.js. There you go, I need
to see the syntax of highlighting these,
all looking good. Let's add it into index. So scripts, source equals box.js and let's put in one. While we're here, let's
put in one for waffle as well. There we go. All right. That's our index done, our box is started but not quite finished
and let's create another new file for our waffles. So function waffle,
x and y again. So this is not where
the box is going to be, this is going to
be where the whole diagram is going to be. So we're going to need those
same variables again as arguments because
we're going to have to set where on the screen the actual waffle is
going to start and then we'll set where
each individual box is. We'll also need, if you
remember, boxes across, so how many boxes wide
is this going to be and also how many boxes
tall is it going to be. So we'll have a couple of extra boxes across
and boxes down. We're going to have the data that holds the table with
the data in it. So we want to have
a column heading, so this is which column is this waffle charts
going to be off from that table and we also want
to have the possible values. So that's the meal that
people had whether they ate in or out or a
takeaway or whatever. So that's our arguments and let's now create a bunch of variables that uses
them, so var x, var y, we've got var height, and we've got var width. We've also got var boxes_down and var boxes_across and boxes_down equals boxes_down. Now, we only are interested in some of the data just for
that one column in the table, we don't care about
any other values that people might
have responded with, we just want the column so
let's use table.getColumn. So we're creating a new
variable called column here, not columnHeading this time, this is going to be
the actual data, an array of those values. So getColumn, columnHeading. So that's that, we have possibleValues is
equal to possibleValues, so we need to know each time
what those headings could be to populate our
waffle chart with. We also need a series
of colors which our diagram is going to use to show those
different headings. So this is a bit of a limitation and you could
make this a bit nicer, so that whoever is using this generic waffle function can set the colors to be whatever they want for
a particular style. I'm just going to put in
some random colors really, just a list of them and
we'll use them here and then you can think more carefully about how maybe you want
this to be designed. So let's put it in red, green, blue, purple, yellow, I should do
one more, orange. There are colors, so that's
pretty much everything that we need to put in in
terms of variables, let's just save
this as waffle.js, small w. So remember the convention is that
you name the file with a small letter and you name the constructor with
the large letter, so Waffle.js and let me just
make sure that in my index. Yeah, I named it right, so I'm being
consistent throughout. So let's go back to waffle. Next up we are going
to want to add some methods to this function. So one of the first one. Well, we know we're going to have this.draw which is going to be called by our draw
function in our sketch. So we got to chain
of draw functions, we've got the draw in the sketch which is
going to call draw in the waffle which would
then call draw in the box. So we'll leave this
blank for now and we'll say draw waffle diagram. So that's what we're
going to end up with. We're one variable
short, actually. Let's add in var categories. This is what's going to store each of the
values and each of the proportions of
how many people have responded with
each category. We're going to say var
categories and this is going to be an object literal that we're going to build inside our function here. So let's do var categories equals list and it's going to
be a list of literals. Say we need to have a variable and a
function to add them, so function addCategories, and to do this we're
going to iterate over the possible values. So this is the list of things that people could
have responded with, so whether they ate out, whether they went to a
restaurant or stayed at home. So we're going to iterate
over those and for each one, we are going to push
onto categories. A new value and that new value
is going to have a name. So let's put this in weights. That will be possible values, I. So whenever the name of
that possibility is. We're going to have account. When we build this Wufoo diagram, we're going to go through
how many people have responded with that
particular answer. So we'll set that to
zero to begin with. Oops, that shouldn't be a semicolon, that
should be a comma. We're also going to
give it a color. So we're going to use that
handy modulo operator here. We've shown you this
a couple of times. But if I take the value of I, then I'm going to eventually potentially
run out of colors. But if I do I modulus,
colors.length, then I can't get a value bigger
than the number of colors because it's always going to return the remainder
of the division. So we won't have an overrun. So let's do that. So colors
equals I modulus colors. It's right in there first. We're taking that from
the colors array. So from the colors array, take I modulus colors.length. If it's less than colors.length, it's going to give you 0, 1, 2, 3, 4, 5. If it goes over, it'll go
back to 0, 1, 2, 3, 4, 5. Okay, so that's good. So that should work. Now, we've got our categories. We're pushing those on. What we now need
today is to work out how many respondents we have for each of
these categories. So that's the next step. So we're going to
iterate over the column. So still in this function. So 4 via I is equal to 0. I is less than column.length I++. So for each one of these columns that we're
going to return or we're going to get from the value of I for each
location in the column, we're going to get the name of a value which is going to be the same as the category name. So we're going to want to find the category inside
our listed categories. Then we can add one to the count. So I am going to add
another little function up here for finding that
location of the category. So let's call that
category location. We're going to pass in a name. This is just going to
iterate over the categories. The reason for doing this in
another function and it's quite the rule of thumb here is because I've got
another for loop. I would end up with a for
loop inside a for loop there where it's not a
natural place to do it. It's no par that drawing a
grid or something like that. So by putting it in
another function, I've made this code quite
a bit more readable. So if CategoryName is equal to, sorry categoriesI.name, so
if we get the same thing, then we are going to want
to return the value of I. Because that's going to
tell us where to put our I to increase accounts because we've seen
that columns information. So return I, if we
get nothing back, so if there's an
error in this data, we might want to be
prepared for that. So if we get to
the end of our for loop, nothing's been returned. Let's return minus1. I'm not going to handle that
anywhere else in my code. You might do well if you're pulling data straight from users without processing it
to actually handle that or if you want this to
be a more general function. What do you do if you
get that minus one? So we can go back now to our
columns iterating over that. Let's have a thing called, it's called a credit
card location, which is going to equal category. Location with whatever
is in column I. So that should give us which category we need to
increase the count off. So if catlocation is
not equal to minus1, then we can increase the
count at that category. So push categories. Catlocation.count++.
So once we run this, once we've iterated through it, we should then have all of our columns have been counted
into the right category. Let's take a moment to run this. Let's just see what's going on. We'll need to add a
little bit into sketch to actually go through this process of adding in those valleys. But let's just do it quickly
with just one of them. So rather than doing
all seven right away, let's just do one as an example. So var will fall equal. I see we need to make that global so that we can sit
easily in the terminal. So let's say Wufoo equals a new Wufoo and we need
to give it an X and Y. We'll just start with values like that or with 100 with 100. We're not drawing anything here. So it doesn't matter too much what other things
do we have to give it. Boxes across and boxes
down so it's just 10-10. The important thing
though is to make sure we've got this table. So that's called data. We also have a column heading which is
going to be Monday. We need one other thing, which was all the
possible values. So from values. Let's run this again. So let's refresh that and let's just have a look
at the inspector. Now, we'll need to
put a break point. I think to be able to see
exactly what's happened, so let's just get sources. Let's put one in
there and refresh, and it should bounce
on that point. That looks good. Then
let's just move on a line. So we should know
if we have a look in categories, yes, excellent. So we've got now our six different categories that people are going to
respond it with and account for how many times our
various different users responded with that
particular value. So that's great. But what we now need to do is convert from those raw values into how many boxes it is that's going to be
that particular color. So the proportion of
boxes which are takeaway, cooked from fresh, ready
meal, Itau, et cetera. So let's move on to doing that, but we've
made a good start. Type back to Wufoo. Let's now iterate. So we could do a bit
of a commenting here, iterate over the categories
and add proportions. So 4I is equal to 0. Lots of looping in this example. So you'll be looking good
at your looping marks, whether they are
real quite similar all its rating over arrays. So you might want to think about slightly more complicated
loops later on. Coming up, we're going to
have some nested for loops. So categories.length, I++. So for each box, we want to do categories I. So that's to get to each box. I'm going to add a new
property to this literal, which I can do just
by writing out a new name that hasn't seen for JavaScript, we'll
just add it on. So category.boxes,
categoriesI.boxes, sorry, equals, we want to round this because we're going
to get a floating point. CategoriesI.counts divided
by the column.length, so that's how many
people have specified this particular category
from the whole length of columns divided by column length. Then we want to times that by how many boxes down we have
and how many boxes across. So that should now go from a
real value into proportion. So if I save this and we'll pause in the
back and let's refresh that, and then if I have
a look at waffle again, or categories again, sorry, we should see we've
got a new field called boxes. So we've got to count 56 but that's going
to relate to you 18 boxes in our work flow diagram because we don't have a box
for every single person, a box represents
number of persons. So we need to work out what
proportion of boxes are of that particular color from the title. So that's
what we've done. So that is all adding columns done and we know how many
boxes we've got to do. So let's now go about
actually putting, filling an array of
boxes for the waffle. So we're getting that
where we're monitoring them. Next to categories. Let's have four boxes, and that's also an
array and let's have another function
called "Add boxes", so I just niggling things up, keeping them separate rather than doing it all in one place. So we are going to iterate over the boxes across
and the boxes down. So we know what
those numbers are, we know how many times
you've got to iterate, and then we're going
to add a box for each one and set the
right category for it by keeping accounts of how many boxes we've
done of each category. So let's start with a for loop. Var i is equal to zero and i is less than boxes down. So we're going to
go each box across. So we're going to have the
down on our outer loop. So we do across and then down. So down will be on the outer, i++ and then for var
j is equal to zero. J is less than boxes across, i++. All right. So that's
our for loop. Now, we want this to be a
two-dimensional array of boxes. So I'm going to say
here boxes dot push the empty array and
it's going to be that array that will
then push into each box. We'll have a look at this
in the console and the structural makes sense then. We need to keep abreast of
what category we're on, and which box we're on. So let's have currents
category is equal to zero. Currents category box
is also equal to zero, and we also need to know how wide and how tall
each box is going to be. Because we know the total width of the diagram and we
know how many boxes, so we just need to divide
that up to give us how many boxes across
we're going to have and how many boxes down. So var box underscore
or box width is equal to width divided by
boxes underscore down. Var box height is equal to height approximately
deliberate mistake, that should be boxes across, and that should be boxes down. So we now know how big
our box is going to be, we've got a count of how many categories
we still got to get. So if currents category box is equal to categories in currents category dot boxes. So in other words,
if we've reached the full number of boxes that we need for
a particular category, then we're going to want to
move on to the next category. So we'd say current
category box is equal to zero again and the currents category we
want to add one too. So I guess that's a little
if statement in there just when we get
to the end of our, so as we're going
through these boxes, when we reach the end of
a particular category, we want to go on to the
next category and reset that current category box
failed to be back to zero. So let's stop putting
on some boxes. Boxes I dot push a new box. So x plus j, times box width. So we're just working
out where we're going to put this box in the diagram. So if we use our value of j, and we times it by the box width, then that's going to give us which box alone the diagram is, that location, and
if we add on x, which if you remember is
the start coordinate, that's going to tell us
where on the screen and how many boxes across
and width for that x. So we will need to do
the same with the j, sorry, the y coordinate. So that will be y
plus i this time, times box height, and then we need to give it
the box width understand it, we know what that is and the box height and we also need
to pass in the category. So should be categories, current category
and then when we've done that we need
to add one to our, I think that's right? Yes. We need to add one to
our current category box. So that's as adding a box. Let's just call that
function down here. So add boxes. Lets save and run that, see where we're up to, we still pause in the debugger, so if I refresh. So we've got another
error on line 66 and it's a bit of a classic
mistake that I've made, that I've see remember
writing in a video that this was a common mistake before. So you can see here
that on this line, on line 60 I've got var
j is equal to zero, j is less than boxes across i++. So a little bit muscle memory, i++ rather than j. So if we do that and then we've gotten spectrum
from this, was pulling up. Spectrum let's
refresh our code yet. So we've gone through that line now and if we have a
look in the console, so let's just look at boxes and you can see
we've then got an array of 10 boxes down and each one of these should
hold 10 elements. So 10 by 10, which is what we said
in our sketch from. We've now got all our box is ready to be drawn to the screen. So just to have a bit
of a play with this. If I was to change
this from 10 to 10 to eight by eight and save that. Let's refresh over here
and if I do boxes, we got an array of eight, which each element
has eight elements. Perfect. So we've basically
got the structure, the data structure behind
our waffles now working. So what we have to
do is draw them to the screen and add a
little bit of interaction. So let's take a quick
look at waffles. We need to fill in this draw, so let's do that now and quite simply all we have to do is
just iterate over our boxes. So var i is equal to zero, i is less than boxes
dot length, i++. I'm not sure if I'm in brackets for
var j equal to zro. J is less than
boxes, i dot length. So the out one is going o iterate over the box's array and
then the inner loop will iterate over each element
of the box's array which is itself interact and get
this right this time j++. All right. So each
time we do that, all we want to do
is to do boxes i, j dot draw and that should be the draw
function in waffle done, and I think we did the
bounding box already. So let's take a
look. Let's see if we were actually now
getting some output on our screen that's lose
our breakpoint x, that's going to
represent, refresh. Nothing appearing
just yet no errors because we have to call it
in sketch of course we do. So we have to go waffle dot draw. Let's also set this away
from the edge of the screen. Let's make this 30, 30, 100 by a 100 and little bit small
so let's make that bigger. Not showing up just yet, so let's have a look
in our inspector, see what might be going on. So I've obviously
forgotten something. So we're calling our
waffle dot draw. In waffle, we are going over all the boxes and we're calling
boxes i and j dot draw, and that should be just
drawing out a rectangle. So let's step through this in the inspector and let's see
what might be going on. Well it looks like draw in
waffle isn't being called, so let's try drawing
in the sketch. For some reason, it
appears that brackets hasn't loaded in
the latest version. So stop that, let's restarts it. There we go, and there
is our waffle diagram. Say at the moment, we can't really see
anything about this, so let's add a little bit
of interaction to it. So what we're going to do
is we're going to go into waffle and we're going
to add a new function. So just after draw,
so this.mouseOver. No let's call this
this.checkMouse, and we'll take the mouseX
and mouseY as arguments, and what we're going to
do is we're going to check all the boxes and see if the mouse is over
one of those boxes. So let's actually write
the code in the box first. So this dot mouse over, we
did this already, didn't we? We created the function, we just didn't put the code in. So is the mouse over this box. So if, and we'll use
that favorite pattern of ours for detecting whether the mouse is within a
certain area of the screen. So if mouseX is greater than x, so the x that
belongs to this box, and and mouseX is less than x plus width, and and mouseY. So we've done our x's now, let's take a look at
mouseY, is greater than y, and and mouseY is less than y plus height, and there we go. So in that instance, then we want to return
this.category.name. So we're going to return
the category name, and then the waffle function, we'll able to use
that to draw out a little label and otherwise, so if that's not the case and in fact we don't need the
else there because it'll always return
this if it hasn't returned that already,
we'll return false. So if it's not in that, this box will return false, if it is in that box, it will
return the category name. Then all we want to
do in our waffle is to check each of those of, and if we find that the
mouse is in function, then we're going to print
out a little label. So for i is equals zero, i is less than, boxes.length, i plus plus for var
j is equal to zero, j is less than boxes, i dot length j plus plus, then we want to check
if the mouse is there. So if boxes i and j dot mouseOver, we pretty don't
want to do this in this if statement because we
want to get that value back, we want to get the
category name back. So let's cut that from there, let's
create a new variable. So equals mouseOver equals
dot mouseOver, mouseX mouseY. So if mouseOver is
not equal to false, we could just put in if mouseOver because it
will have a value. Then we are going to
draw a little label. So that's just push here to keep our drawing contexts
when previously, and we'll just say,
fill to black, and let's set
textSize to be at 20, and we need the texts
width as well because you want to know how long a little
box to draw around this. So if I do tWidth is equal
to, if you remember, there is a text width function
in P5 which tells you how big a piece of text is based on what
the font size is. So textWidth, and that's
going to mouseOver, and then we've just got a
couple of extra things to set just to make sure the alignment is
right of the texts, left top, and let's draw
a little rectangle. So this is going to
be a little label, we'll need to set the fill to zero first and then change
it back to 255, so rect. This is going to
be mouseX, mouseY, so it's going appear at
the location of the mouse, and we'll make it tWidth plus 20. So a little bit of padding, and we'll set the
text size to 20, so let's set this
to 40, so there's a bit of top and bottom padding. Well, once you set the fill
back to black, hang on. So that's y, and let's
just draw out this text, so mouseOver, and
this is going to be at mouseX plus 10, mouseY plus 10. So we're just setting where exactly that's going to
appear on the screen, and then if we pop
the drawing context, and then finally,
we'll just break. So if we found a box that has the mouse in
it, there can only be one. So we might as well stop
it writing over this loop, save some CPU time, and just not look any further. So that'll stop us from locking. So if I add here to
this sketch file, we'll just each time here
do waffle.mouseCheck, I think was it mouseCheck. Just check what I called
that, checkMouse, I knew that didn't sound
quiet right, checkMouse. Let's see if we've
introduced any new errors. It looks like we've got
something in there. So let's have a
quick quick check. Inspect, console,
unexpected token, line 85. I've done this inside
of a function maybe. This.checkMouse should
say that equals function. You'll see that I make the
same mistakes quite often, it's quite common for a
programmer that you'll have your little things that
you do over and over again. So nothing's appearing yet. So let's just put
in a break point, and let's see if we're
getting in here all right. It doesn't appear that we are, so why is that not being called? Let's just have a look
at the sources again. That's been cooled okay? So if I move into there. You see what I've done
now, I've spelled length incorrectly. So let's change that. That looks better. Let's say if I move forward as it stop. It's stopping in there now. So I think we're probably good. So if we just save and run
this we should say, yeah. We've got labels telling
us which thing is which. Okay? So a [inaudible]
and someone can look at this and see what proportion people
did well on Mondays. Let's try and do this
for the whole week. So should be quite simple and straightforward
from this point. We've got our sketch, and we've just added
a single waffle. So let's comment that out, and now let's add all the waffles for each
of the days of the week. So for our i is equal to zero, i is less than days or length. i++ and then all
we have to do is, create a new waffle
for each of these. Now, the one tricky thing to
do here is to set them up so they fit across the
screen in the right place. So we've got our array
here for our waffles. So workflows dot push. So we're adding a new element
onto that waffles alright? And it's going to
be a new waffle. The tricky thing is these
X and Ys because we want them to move out across
the screen nicely. So the way I've done this is to have four days on one row and
then three on the next row. So there's a little
funny bit here. So what I'm going do
is I'm going to say if i is less than four, and we'll just then otherwise we'll push
them down to the bottom. So if it's one of our first four and let's
do a bit of padding. So let's say 20 plus i times 220. So we're going to make
each one of these 200 across bid a padding
on either side, so 20 either side, and that's going to
be our x-coordinate, well this is always going
to be a fixed value. So let's say 20, 200 by 200. So that's the width, the screen width and how many
waffles do we want across. Let's say 10 by 10, and the data was the
next thing we gave it, and then we also need to
give it which column? So this is going to be days
i so the column heading, and we'll get that
from that day's array, and then we've also
need our values. Say that's what are the
different categories going to be on the
waffle diagram. So that's waffles being pushed onto the array
for the first fall. In the second line, it's very similar here. Waffless dot push just changing the padding and the y-coordinate. So new waffle, and
we're going to make this 120 plus i times 220. Then the y-coordinate
will be 240. So 20 padding plus the
200 for the top waffle, and then each one
will be 200 across, and 10 cells by 10 cells. We've got our data, and
we've got our days i. So which one it is
we're putting in there? And our values. Okay. So that's all
our waffles drawn. Now they're not going
to pay yet because we need to add them
to the draw function. So we just need to iterate over our waffles for i
is equal to zero, i is less than full-stop
dot length i++. So that's really
waffles. I dot draw. So let's draw each of them out. Let's make this a
little bit bigger. I also want to check
for map service, so as to another loop. Now I'm doing this
in separate loops, and you might think well do them in one that saves some code. But actually we want
to make sure that everything draws out correctly without the label being obscured by another waffle diagram. So let's do it separately. Waffles dot length i++. Okay. So save and run that. Now we will get an error here, and if you remember right at the beginning quite
a long time ago, I said on it there's
some reason why we need to have the categories as a public variable of the box, and there's a bit
of a problem with my code for doing
the proportions. It's not totally satisfactory, and when we round it down, we might get one
cell or too many or we get 99 cells filled
with proportion, and one that doesn't
have anything there. So we're getting
an undefined box. It's not being drawn, and our display isn't working. So all I'm going to do
is just to fix this up, as where we've already
got our categories being shed from the box. So all I'm going to do is I'm just going to check and make sure that there is definitely a
box that is not undefined, when I come to draw it. So if we get back to waffle
and to the draw function, and here if we just
say if boxes i and j dots category is not
equal to undefined. Then we can do a better drawing, and this only shows
up this error on some diagrams not on all of them. So it becomes a problem
not with Monday, but with some of the
other days and you'll see it when we're done. So let's do another one here. So if boxes i and j are not equal to undefined, open that there and close it in the right place there. Okay. Save that. Alright,
still not working, so we might have
another little bag somewhere let's just check, [inaudible] to identify
on sketch line 35. Okay. Cannot read
massive undefined, so we do still have
some error there. You can see there where the proportion hasn't quite worse. Let's just see what that is. It's still crossing
this error on line 36. Yes. So lost the error that needs to be dot
category of course. So dot category, save that, and we're still
getting an error here. Cannot reprompt to check
massive undefined. Why are you an error? That's because we have
another tiny error there. What I've done is, I've not put in i. Now we're okay. Hopefully now that shouldn't give
us any more bother. Here we do still have
one error showing up. Cannot read property
zero if undefined. Okay. So we still got
a little error here, and this needs to be the i
and also needs to be waffles. Okay. So let's save and run that. Well we're getting four of
the map showing nicely, and why am I not
getting my other three? Let's take a look. So no
errors in the console. Let's just refresh and see if we're getting into
that predicate. Yeah we just seem to be. So let's just have a
look at waffles here. Seven waffles, but
they're not being drawn. So we probably maybe not drawing them in the
right location, and we got a small mistake there. Of course yes this needs
to be i minus four. I minus four because we wanted to go back to the start
of the screen. So 120 plus i minus
four times 220. Okay let's try that. There we go. Okay, finally got all
our waffles loading up. Quite a few errors was
creeping into my code there. So sorry about that, and you can now see we've got
all seven waffles. It's looking pretty good. You can change this round,
I mean been quite easily. We can just say let's make these eight by eight rather
than 10 by 10. So let's do that. Again and there are slightly
different proportions. That was slightly
different number of rows and columns. So you
can change it around. You can play with the colors
make it look how you want, and use it as a start point for building your own
data visualizations on data you've collected.
________________


Week 11 - 6.207 Extending the apps
In this topic we have introduced you to the second set of our extension ideas. Discuss the following aspects of their design.
* What do you need to do to integrate the extension with the template application?
* How might you enhance the extension with your own ideas?
* What challenges might you face implementing the extension?
Make sure you are clear which of the extensions you are interested in implementing in your response. If you haven't chosen which template you want to extend yet, you can talk about all three extensions and how they are influencing your decision.


________________


Week 13 - 7.101 Project progress check


In the last topic, we introduced you to
the midterm assessment. You should be currently working on preparing the submission. In this topic, we will show you the lost of our extensions. By the end, you should
be making decisions on what you want your
final project to be. The extensions in this topic are the most complex we'll show you, and we'll test the
knowledge that we've built up over the last one
and a half modules. This is the standard of
complexity we will be looking for to achieve
excellent marks on the project. As ever, it's a good idea to go through all the
extensions in this topic. Do this even if
you're sure that you don't want to undertake
this particular project. It will allow you to see a broader range of
ideas and techniques. Following the
extensions, we'll show you a few brainstorming
techniques, and start thinking about
how to scope your projects. We'll also have a final
student interview.
________________


Week 13 - 7.204 Extending the data visualiser: dynamic presentation of data, part 1
On sites like information
is beautiful dotnet your often find visualizations where
you can select different options and the items on the screen will rearrange
themselves in an animated way. We're going to have a go at creating our
own version using the family food data set again. And this time we'll be looking at
household consumption of different food items. Okay. So in case you've forgotten where
the family food data set is I can show you the link now,
it's gov dot UK forward slash government forward slash statistical- Data-
sets forward slash family- fruit- datasets and
I'm showing it to you on the browser. Now, we're going to work with
a different document this time. We're not going to take
the nutrient intakes. We're going to look at
household purchases. So I'm going to download
that I've got it here. And the first thing I'm going to
do is Open it with OpenOffice. And if we look at household quantity we
can now see that there is a lot of data and if I show you some of the stuff
we can see that there are top level categories such as milk and
milk products excluding cheese. And then you get the various different
types of all the different types of milk. You could buy the same with cheese. So this is carcass meat so you can
see whether it's split into different meet types and then there's other
types of meats and fish and so there's all these different categories and
then the items are mostly in grams, but you'll see occasionally for
liquid items milliliters as well. And as with the other data sets,
it runs from 1974 all the way up to 2016 17 But
you can see but some items they were obviously no longer
collecting the data in this case or they didn't collect the data for
that item earlier on in other cases. So I'm going to cut and
paste this whole page into Excel. And as I said, if you don't want to use Excel you can
always use Google Sheets to do this work. Okay, so I'm going to need to do some
cleanup of this data to make it work for us as a CSV file. So first of all, I'm going to delete
this First Column we don't need this. And I'm going to delete all of these rows
down to the header deletes entire roof. That's what I needed. There we go. I'm going to keep the units that
could be useful and I'm going to get rid of some of the columns at the far
ends because we don't really need Rose. So I'll go up to the top. So all of these columns I don't need And I will delete those. I'm also just going to tidy up some of
these year headings at the end where they're obviously applying to multiple
years, but this doesn't quite work for for my purposes. So I will call this 1 2016 and I'll call this one 2017. Okay, the final thing I'm going to do
is I'm going to add new headings for each of these columns because
I need them to be labeled. So instead of calling them description. I'm going to call this level 1 level 2. I'm products. It's killing excluding cheese is actually
made up of all of these subcategories and those subcategories are made
up of Sub sub categories and even some of those Sub sub categories
are made up of even smaller categories. Okay, so
it's makes it a bit strange if we try and compare the top level categories with
some of those smaller categories. So instead what I'm going to do is I'm
just going to display these L1 categories. So I'm going to need to get the number of rows so I could go. Let's see we're going to iterate
through all the rows of our I equals 0 I is less than Theta dot get row counts. I believe is the argument I plus plus And inside that we're going to check if there is any think in L1, so I could in order to do
this I could get the road. Let's try that data gets row at index. I And we could then get the value for L1 column. So I might need to look now at the P5
documentation in order to do this. So let's look at p5.js or / reference and I'll go to table table row and if we look where we're going to
be getting a string, aren't we so get string the column may be
specified either by its ID or title. So let's do this our daughter gets string and we know we're looking for L1. and I think what I'll just do for a moment
is console.log that and see what we get as the output before we decide how
to program it so we can see there. That we've got all these
different items have been printed you'll notice that
lots of spaces are printed and the spaces that are printed
are where there's no item in that L1 column so
we could say to get rid of those spaces. We could say if our DOT get string. L1 doesn't equal an empty
space shall we see? Let's see what happens if that works. So will only print if we have
if we've got some text there. Let's see now whether that works so
will refresh again. Whoops, it's gone wrong. I'll just do that one more time. Okay, and now you can see
I'm only printing the items where L1 the L1 column has some data. So that's great. So that means that we're just filtering
through the data in a more sensible way. Okay. So the next thing is for each of these
items we're going to want to create a new bubble and add it to the array bubbles. So I will just put for the moment bubbles dot push new bubble. And if I do that and run my code if I
have a look at my array now bubbles. Yes, I can see that. I'm going to end up with
twenty four bubbles. Now, obviously at the moment
are bubbles are just empty object. So we need to do something with them. So I think the first thing I'm going
to do is give each bubble a name and so we'll have a name argument as
part of a Constructor function and I'll say this dot name
equals underscore name and I think it would be good to just
draw these to the screen for a moment. So I'm going to make a draw method. And we will just say text. We'll just put it in the middle
of the screen for the moment. So this is going to be pretty messy. I should put this dots. Name as well. And let's do that in Black text. And no strike. Okay, great. So we actually need to
pass the name through so this will be R L1 item so I can see a little bit where we're
being a bit in an inefficient here. So I think what I'll do
is I'll put VAR name here and get it from this argument. Because this will be a little bit neater
rather than repeatedly calling that method name there and we don't need to
console log anymore instead. We will do that. And so the final stage here is just to
iterate through our bubbles and draw them. So I need to start filling in
our draw function as well. So I think I'm going to just
clear the background and we'll clear it to a kind of gray and
then I've got to do a for Loop and Traverse my bubbles array. Okay, and I need to go Bubbles at index. I dot claw and hopefully we should see
as I suspected a horrible mess of text. So this is all of our different bubbles with the different titles so that all on
top of each other so we can't read them. So I think the next thing we need to do
is start giving these bubbles a position. So I'm going to say that
this dot pause equals. I'm going to use the vector
object to do this. I'm going to create
a vector create vector and it will have its Exposition for
the moment is just going to be zero and it's y position is the bit but I'm going
to make random so I'm going to go random somewhere between zero and five hundred. Okay, have I done create
that something's wrong. I've got a bug create
Vector is not defined. I've forgotten the commands. Let me have a look. It's doesn't have a Capital C
at the beginning. Of course. I hope you can see by the way from
these moments where I have to keep looking back at the reference. This is a very natural thing for
a programmer to do we don't remember whole apis of by hearts and so
often when you're programming you're using the web-based reference from
just going backwards and forwards. Okay, so that should be working now. Yes. And I now need to adjust my drawing
code to take that into account. The first thing I want to do is
I want to draw these bubbles with a different origin because I think
this will become useful later on. So I'm going to do a push Anna pop. And I'll do it in my main. Sorry not there. I'll do it in my main drawing code. So I'm going to push and pop. And I'm going to translate myself
into the center of the screen. You'll notice we do this quite a lot. It's quite a standard thing to do so
Translate. width / 2 height divided by 2 Okay, and now obviously I haven't
adjusted this other drawing codes so you don't really need to worry why but
we can't see the text anymore properly. So I need to do some more work here. So instead of drawing in this
Center screen position here. I'm going to use pause this stop pause. X and this stop pause dot why? Okay, and now you can see my my
text going down the screen there. Another thing I might
want to do is actually make the text align to the center. So I think I'll also do this
in my main draw function and I'll do inside my push and
pop in case I want to draw any text later. That means that this will
only happen inside these two commands text-align:center. Good. Okay.
So now we've got our scented list. The other thing is I think I
just want to make these values spread equally positively and
negatively around the middle. So I'll just for the moment Go - two
hundred and fifty to two hundred and fifty and we should see them spread out. That's great. Okay. The next thing I want to do is draw
a little ellipse for each bubble. So I'm going to do that. So let's draw an ellipse. And the ellipse can be in position
paused or X pause dot Y for the moment,
I'll just make it have a diameter of 20. Something's gone wrong there. Let me just try that again. Pause is not defined. Of course. Look, I forgot to type this
this stop pause this dot pause. Okay, and
I also want to give this a lipstick color. So I want to have a spread
of different colors. So inside the Constructor function,
I'll make a variable called color and I will make a random color for
it so color and we can go random something
between zero and two five five and
we'll just repeat that for r g and B, and that will give us
the spread of random colors. And then we need to adjust the fill for
that fill this dot color. Okay, and obviously the other problem here
is we want our text to be above our lips. So these are in the wrong
way round at the moment. So I think we need to do this and now we can see but we've got our
bubbles drawn to a sort of fashion. Okay. So the next thing we want to do is we need
to get some values to add to the bubble. And so I'm going to make a new method of bubble and
I'll put it underneath here and I think we'll call this one set value and will give it an argument as well the and we'll put it here this dot size. Equals, sorry this starts. Yes.
Let's go this start size and we'll make that 20 at the moment. and yes,
let's see what we need to do here. We're going to need to
I've got an error as well. Let's just check whether
that's a real error. V is not defined This not set value. I made a little mistake
that equals function V. So when I set the value, what we're going to need to do
is to change the size variable. Okay, so
I could just put this stop this starts sighs equals V, but
this isn't going to work and I'll show you why because if
we look at our values here, some of them are really enormous so
you can see that some of them are into the into the thousands there and some of them are really really tiny and so
we're going to need to map these values. So one way we could do. This is we could cycle through
the table and find the largest value. That would be a really good way to
do it for the sake of this video. I'm going to do a kind of Version, so I'm
just going to look for the largest value and I think the largest value
is maybe something three and a half thousand see if I can see a 4001. I don't think so. So I think it's going to be somewhere
to three and a half thousand. There will just check. Yeah, that feels about right three and
a half thousand. So I'm going to say that
this dot size equals map. The and our input value is anywhere
between zero and three thousand. Let's say 3600 just to be safe and our output value will now we're thinking
about the size of our drawn bubble. So I think the minimum I want it to
be as five which is really tiny and the maximum it could be is maybe 200 Okay,
and then instead of drawing this ellipse with this dot size which
sorry with 20 as a hard-coded value. I'm going to put in this
Dot sights in there. Okay. So at the moment all our ellipse is of
the same size, what we've got to do now is actually get the value out of the data. So for the moment, what I'm going to
do is I will work with the year 1974. Okay, so
we'll get 1974 values at later on will be able to to shift years so
I know that 1974. Is column number so
it's not one two, three four five. So I'm just going to do that. So this is kind of a naive version. So we've created our set Value method, but now we actually need to of course get
the data out of our data table and call it as we're creating
these different bubbles. So I'm just going to use for your 1974 to start off with and
what I'm going to do is I'm going to if we look in the documentation and table is it table row will use the get methods
to get the value out of a table. So I'm going to do a couple of
things in order to do this. I think I'm going to save all A equals r dot get and we can just get the year 1974 so
that will get us when we're going through our code just to explain what's going to
happen when we're on milk and products. It will get us this number when we
want cheese will get this number. We're on carcass meat will get that one. And so on one thing I've done is I've
used this method specifically because somewhere down on this sheet. We have some empty columns so
under soft drinks, for example, there's an empty value and if I used
to get normal the get string method, you'll find your actually get an error
which is quite tricky to debug. So I'm going to use gets and then what I'm
going to have to do is make sure that this is a number that I'm interpreting. So I'm going to go number and put that in Brackets around this and
that will make sure That I've converted with type to a number
because otherwise it could be a string. Okay.
So now I actually need to call
the set Value method in bubbles. But there's a bit of a problem here in
the I created this thing on the fly. But now I've got no way to refer to it. So what I'm going to do is I'm going to
actually assign it to a local variable as I create it. So I'll call that local variable B and I guess vanitas way to do
this would be that whilst we have that variable we call set value. And we pass through our value and
then we push it to the back of the array. Okay, if I do all that and
have a look at the outputs you can now see that my bubbles are all different
sizes based on the amount of consumption, but that they were there was but
the next thing is is we don't want all these bubbles to
be kind of on top of each other like this. What we want them to do is we
want them to spread out nicely and arrange themselves
in a readable pattern. So in order to do that, we're going
to need to do quite a few things. We're going to need to do some give them a direction to move and
then do some Collision detection as well. So I think first of all I'm going to do
the create the direction to move in so This dot will call it dear and
we'll also create a vector for that. And to start off with the direction or
just be nothing. Okay. So the next thing I'm going to do is
I'm going to create a new method and let's call this method update. Direction And it will take make that equals function. It will take an argument and
the argument will be the array of bubbles. And this is because when we do Collision
detection, we're going to need to check this bubble against every other
bubble to see if they're overlapping. So the next thing I'm going
to do as I do that is I'm going to create an a unique ID for
this bubble. I could just use the name. I guess. I'm a little bit worried that
there would be a clash somehow. So I think I'll make a little
random string generator. So I'll make a separate
function called get random ID. And if I just make a string? Good, I'll call it Alpha for alphabet and
I'm just going to type the alphabet in. And maybe I'll put in the numbers
that should be enough and I'm going to make a random string
simply by iterating for your efforts. Sorry, not iterating through that is
racing through the number of characters. I wanted my string. So I'm going to say 10 would be enough and
then I could make a string of RS and let's start with an empty string and S for
each time I go through this iteration. I'll add to the end of a string
a random character in the way. I'll do that is go Alpha at position and
we'll take a random number for that and it will be somewhere
between 0 and the number of characters we have here which can
just be determined by Alpha dot length. And that's what if you
remember this returns a float. So I need to make use floor to
make sure it's an insect and that will get me a random string and
then I return s so that will get me ten random letters so
I can then this ID equals get random ID. Okay, so now all of my bubbles
should have a random ID. I can check this I could go bubbles here. Let's take a look at a bubble. So this one and it's ID. There is just this random
string of letters and numbers. So the chances of those colliding
are very small the chances of them being the same for
any two bubbles in my sketch. So that's good. Okay.
So in update Direction, what I want to do is I want to
iterate through all the bubbles. So I go for VAR. I equals 0 I is less than and we're going to use this argument
here bubbles dot length. I plus plus and the first thing I want
to do when I'm traversing that bubbles array is make sure that I
ignore the current bubble. So I go if bubbles I dot ID now,
you'll see why we're doing this. Equal doesn't equal this ID. So only on this occasion,
do we do these things? So that's going to be every single
bubble apart from the current one. Okay, and the next thing we want
to do is calculate the distance between the two Bubbles and
I'm going to do this. I'm going to stay in the world of vectors. So I'm going to call make
a very local variable. I'll call it V four vector. And it will be the the this position. And then I'm going to call the method sub. And I'm going to subtract the position of the other bubble
that we're talking about bubbles. I don't position. Okay, and now I'm going to look at
the length of the of the vector. So we're going to see if it's closer than the if it's if it's overlapping if it's
closer than the size of this bubble. So if we look back at reference for P5 vector We look at these methods you should see that there is one called
mag some mag stands for magnitude. And that's the same as
the length of the vector. That would be the distance
between any two of our bubbles. Okay, so we'll call that D. And if the Saudi equals the dot
mag not maps right mag. Okay. Now we need to check if they
are indeed overlapping so if D is going to be less than this dot size. I divided by 2 because it's a diameter. So we're going to look at the radius
plus the other bubbles one. Dot size divided by 2. So if you think about it,
if you've got two circles and we're thinking about the center
of each circle when they overlap. Okay, the centers of those circles need
to be less than the combined radius of both of them. That means we have a collision. Okay, and maybe I'll just for the moment. We'll do something silly or
just console.log Collision. Okay to see if this is triggering at all. Okay, so we should expect
collisions because if I show you my sketch you'll notice that lots of
these bubbles are overlapping currently. So the next thing is we actually have to
make sure that we've called this function. So in the draw function before I draw
the bubbles, I think I will go bubbles. I dot update Direction. And remember we have to Pub pass
in the bubbles array as well. Okay, I've used I can see
a little error in line 90. But somehow ended up there. That shouldn't be there. Should it good? Okay, let's have a look and you can see that collisions
been printed lots of times. Nothing has been drawn,
which is interesting. I wonder if I just take that out for
a moment whether that changes in a fink. That's that's very strange. I think that somehow this is gone wrong. I can see this. Let me explain this little error here. So you might know this already. So P5 in Vector objects in couple
of objects has a distinction. It has methods that are kind of dynamic
and that affect the object you're working with and there's methods for a static I've
used a dynamic method, but I need to learn that means that I've changed the position
of the bubbles by subtracting them. When all I wanted to do
was get a returned value. So actually what I need to do is
to go p-- Five Dot Vector dot sub. So this is the static version and then I need to subtract this
stop pause from bubbles. I pause and that should actually
get me that's much better now we can see I looks like Come and
sit out the console log. So let's see now and
we can see lots of collisions happened there which which
makes sense as well. Okay, so we don't just want to
print Collision to the console. We actually want to start
moving these bubbles. So what we're going to do is we're
going to take the distance between two overlapping Bubbles and we're going to take that vector and
we're going to add it to our Direction. So I'll go this dot dear. Now I won't use the static method. I'll use the dynamic one ad and our Direction the difference
between the two is V. Okay, so you imagine for every single one that's overlapping
we're going to add these directions. Okay, and that will then kind of some
a movement that we can get our our bubble to make
the other problem we have here is if we add all of these directions
the numbers are going to be huge and if we then try and move by right direction
are bubbles really going to jump so I actually want to get a standard
length of this vector and the way we do that is we call
the normalized function. I think we've used this one before
if you remember normalize make sure that the length of
the vector is exactly one. Okay. It doesn't change
the direction of a vector. It just makes sure that it's length is
1 so at the end of all of this process I go this dot d r normalize. Okay, and
then finally when I'm drawing the ellipse, I'm going to want to change the direction. So I will go this so change the position
according to the direction. So I go this stock pause dot add this dot
d r so this will start moving my bubble. The other thing I need to do you'll
see this will kind of go wrong now so everything will just keep moving now. So this hasn't quite worked yet. The other thing I need to
do is I need to make sure that the direction is set to zero
before I do all of this process. So this dot d r equals I
can just make a new Vector create Vector 0 comma 0. Otherwise, we carry over that direction
even when they're not overlapping anymore. So there we go. So that's our bubble sort of spreading
out and you can see eventually they stop we still got another problem in that
they're all in a in a straight line at the moment and you can see they
haven't spread out in different areas. So we want to do a couple of things. I think I'm going to start with my
bubbles instead of them having a random y position. Now I'm going to have them all
perfectly overlapping and the second thing I'm going to do if you see they're
perfectly overlapping nothing happens. They don't move. And the reason for
that is that there's actually no Vector there's no difference between
their positions and so we can't get a direction from
a vector 0 0 so in that one case what I need to do is I need to say Eve D equals 0 so if the distance is actually
0 we're going to do one thing. Otherwise, we'll do our usual Behavior. oops What we'll do here is we'll
go this dear dot add. I'm going to add just a random vector and
you can get this in P5 vector. You can get a random 2D which
will give you a random Vector that has a length of 1 so
that's exactly what we want. And this will mean that we
start with some distance. So let's have a go at this and now you can see our Bobble spreading out
and they nicely arranged themselves. Okay, I've been going for a little while. So I think what we'll do now is
we'll stop and we'll pick up and look at how to look at different
years in another video.


________________


Week 13 - 7.205 Extending the data visualiser: dynamic presentation of data, part 2
Okay. So we've got our data
bubbles for the year 1974, but actually what we wanted in our data visualization was so we could click a
series of buttons, and we could change the year
that we were looking at. So what I'm going to do
now is implement that. The first thing we're going to need to do
is we're going to need to create some
buttons for those years. So the first thing
we want to do here in perhaps the setup function, is just to work out what years we actually need to be
creating buttons for. Now, if I open the console and we have a
look at the data object, we can see that it has
an array called columns. If we look at columns, we can see that after column
five is when our year start. Sorry, from column
five our year start. So what I'm going to do
is I'm going to create, we'll just do it locally, I will create a- in fact I won't. I'm changing my mind, I'm sorry. I will create it globally
a variable called "years," and years
will be an array. Then I'm going to just traverse through my data from position five up to data at
the end of the table. So data.getColumncount. There we can add years.push. Let's put data.columns at position i. Not "year," sorry. My bad, "years." Let's have a look and see
whether that's worked. I just need to restart my sketch, and here we are. Let's have a look at years. Then, you can see all of
my years pushed back. So the next thing
I want to do is to create a button for each one. Maybe I'll look at
libraries here. Do we have p5 down
the list? Check here. Here we are that's better. Right. So createSpan(),
createDiv(), createButton(). So that's what we want to do. So we'll have a look
at this method, and we put the title in there. So, I can go createButton(), I might assign it to a
variable createButton(), and its title will be
the years so years[i]. Now if I just do this, I'll save this and
show you what happens. Where are the buttons?
There they all are. Now also I can see
undefined so something has gone wrong there. Yes. We're starting from five so that wouldn't
be years[i]. I think the easiest
thing to do is just to assign this to a string. So we'll save our
year as a string. We'll push it back
to our year's array, and we'll create a button. So you can see that
all my buttons are at the bottom at the moment. Actually I think I
want them at the top. So if I look at my index file, I could control this a little bit better by
creating some divs here. I'm going to make a div, and I'll give this one
id equals canvas-div. I'll make a div before that, and we'll call this
one "year-div." Okay. Then we can use
the parent's property. So if I look back
at the p5.Element, there should be somewhere
that we can set the parent. Let's just check. Here we are, we just
used the parent method. So if we go back to our code, we can go var c
equals createCanvas. C.parent, and I don't
think we need to put the hash tag in there. Let's just have a look. Yes. We don't need to
put the ID hash tag; it assumes that we've got that. So that's there and
for the buttons b.parents equals I already can't remember what I called it. I called it "year-div." Okay. Now you can see
my buttons at the top. Now you might want to in
your implementation make this a lot more snazzy. You might want to put the buttons in a
column down the side, do some styling, but for the moment I'm just going
to leave it like that. The next thing to do is to
implement button pressed. So I think it's mousePressed. Let's look back again
at my documentation. Yes. It's mousePressed. B.mousePressed, and
we've got a function. In here for a moment we'll
just do a console log, and we'll just say pressed, and you'll see it will just
check that this is working. Okay. So let's check that
this button is working then. So I'm going to press
one of the buttons, and you can see years
pressed is going up. But we want to get the
year out of the button, and then do something
based on that. So instead of just
saying pressed now, I'm going to console log this. If we console log this, we should see that we get this element object
posted to the console. If we have a look down, we can see that there
are all these things but there is this property
called "elt." Elt has loads of
properties there, and I can get things
like inner HTML, and you can see that that
would give me the year, or in a text. Or I could for that
matter set the ID. But I think what I'm going
to do is I'm just going to get the inner HTML. So I go this.elt.innerHTML. If we do that now
I should just get the year out of any
button that I press. Great. Okay. So we've
got part of a way there. We're going to leave
this buttonPressed function for the moment, and what I'm going
to do is I'm going to adapt my bubble now. So the moment we just
had a value called size, but what I want is for the
bubble to actually store all the years' values internally. So I'm going to give it
a property called data. I think what we'll do is that at the point
at which we create it, we'll also pass through the data. So we'll say this.data
equals underscore data. What I want the data to be
is just the array of values. So if we look back at
our original table, data should be each of these
going all the way across. Okay. So I need to go back to my very beginning loading code, and as I go through, instead of just doing set value, I need to go through every year. So what I'm going to do now
is I've created a new bubble, and let's go iterate
through the years array. So I'm going to for
var j equals zero. I'm using j because
this is a nested loop. J is less than years.length j++, and I can enclose
this command here. Instead of just hard coding 1974, I can go years at position j. So this will go
through each one 1974, 1975, 76, 77, and so on. Okay. The next thing I want to do is I want to store all of
these values in an array. So here I will go var d for
data or should we just yes, let's call it d for data, is an empty array. I will push back the data. So d.push v. So we're going to add each
of those values there. Okay. That's good. Also, what do I need to do? I need to pass that through
the constructor function. So, this won't work here
because I'm not ready yet, I don't have my data. So I'm going to pop
that one down there, and I will pass through the data. So having done all that, if I look back at my code, we can see some things
have slightly broken that, but we won't worry about
that for the moment. If I look at bubbles, and I look at one bubble, I can see but I now have my data in an array, and that's perfect. Okay. So the next thing I want to do is instead of
saying set value, I'm going to change that
method's name to set year. Set year will have an index. Well let's just put year there. Inside that I think
what we need to do is actually lets put year index. I think that would be better. What I'm going to do
then is take this code. Sorry, I'm going to undo
a little bit of this. Year index there. So you should have this if
you're following me here. In this code, what
I'm going to do is I'm going to extract the
right value for v. So I'll make a var v
and I'll say that it is this.data at year index, and that will set my new size. Okay. So the next
thing we need to do is actually change this. So if I do set year
and I set it at zero, you will now see that our
1974 picture is configured. If I changed it to set year, I don't know, let's take a guess, 10, It might be hard
for you to tell, but these bubbles will
be different sizes. Okay. So we'll start
with 1974 though. So when we press the button, we're going to need
to do a few things. We've got the string of the year. So I'll call this
var year string, and we're going to need to find its index in that year array. So, I don't know if you've
seen this command before. There's a command
called index of. If I go to w3schools
actually that's quite good, and we look at index of. An index of, if you look
at this documentation, just returns the index
of an item in an array. Okay. So I'm going to try this. So I'll go, var year index equals index of. Sorry. We need to start
as a method of the array. Years.indexof, and we'll
put in year string, and for the moment,
I'll just console log year index and we
should see this working. Okay. Let's have a look. So I'm going to press
one and we can see But that was 1999
and it's index 25, 2017 is index 43, and 1974 as we would
expect is years error. So that's working fine. Now, all we need to do is we need to change vyears
is for all the bubbles. So I'm going to go for
var i equals zero, i is less than bubbles.length, i plus plus, bubbles at
the index i.setyear, and we set it to year index. Okay. Let's try this out. So if I click a button, you'll see that all the
items will change size. You'll see also that
the rearranging is happening as well. Okay. Good. There's
some anomalies there, but we'll have a look at
those in a little bit. So the next thing to do is I want the bubbles rather than to
just switch to the new size, I want the bubbles
to gradually grow. So this is quite
simple to implement in the bubble
construct a function. So I'm going to make
a new variable, a new property
called target size. Target size will equal
size to start off with. Then, instead of setting
the size in set year, I'll set target size. Then, if size doesn't
equal target size, so if this.size is less
than this.targetsize. So I'll do this in
draw because this happens over and over again. Then I can say if this.size
is less than target size, this.size plus equals one, and I can also say, if this.size is greater
than this.targetsize, this.size minus equals one. So that will make it shrink and grow until it reaches
the correct size. Hopefully, that should
be a little bit more animated. Let's try it. So I don't if you could see that. I'll select another one, and you can see things shrinking and growing quite satisfyingly. Also it seemed to, I was just going to try
and find some of my data anomalies but I didn't
seem to have them anymore. So that's good. So
now we can check. Let's do a big contrast. So we're going to look at 1974, and you can see that milk products were
a lot more in 1974. No, that's not true.
Let's try another one. What goes down and up? Fresh and processed vegetables
including potatoes. Let's see if that
changes over time. So in 19740, I'll check 2017. No. Fresh and processed
potatoes seems to change. So you can see some differences between these items
and you can see that other things have
stayed quite stable. So this gives us an
understanding of how people's consumption of
different food have changed. Now, this is just a start
that I've made here. For one thing, it would be
really useful to display what year that
you're working with. For another, you might want
to be able to click on one of these bubbles and it then splits into all
its subcategories. You also might think, is this the fairest way
to compare these items? So is it fair to compare
things in different units, in milliliters to grams? Is there a fairer way of scaling these values proportionally
so that you get a more meaningful way
of comparing them? Okay. So that's my demonstration and then see what you
can do with the code.
________________


Week 13 - 7.206 Discussion about extensions
In this topic we have introduced you to the final set of our extension ideas. Discuss the following aspects of their design.
* What do you need to do to integrate the extension with the template application?
* How might you enhance the extension with your own ideas?
* What challenges might you face implementing the extension?
Make sure you are clear which of the extensions you are interested in implementing in your response. If you haven't chosen which template you want to extend yet, you can talk about all three extensions and how they are influencing your decision.
________________


Week 14 - 7.301 Exercise: progress log (assessed)
As your project progresses, it is helpful to keep a log of what you have achieved and what you are planning to do next. Not only will this help to keep your project on track but it will allow us to see how you have approached your project and tackled a larger application.
In the second half of each topic, you will be need to complete a log. Make sure you use the following template.
In your log you will need to include the following:
* Your project title and the current topic.
* The progress you have made this topic .
* The problems have you faced and whether you were able to solve them.
* What you are planning to do over the next few weeks.
* If you are on target to successfully complete your project.
* If you aren’t on target, how you will address the issue.
You will need to compile and submit all your logs at the end of the project. So make sure you keep them safe on your computer. When you have completed all the logs, convert them to a PDF for submission.


________________


Introduction to Programming II Project Log
What progress have you made this topic? 
What problems have you faced and were you able to solve them?
What are you planning to do over the next few weeks?
Are you on target to successfully complete your project? If you aren’t on target, how will you address the issue?
________________


Week 14 - 7.302 Progress log
Discuss the progress you have made with the project this week. You may find this useful when completing your project logs.
You may want to talk about challenges you have faced with your project or any techniques you have used to achieve good progress.
________________


Week 15 - 8.101 Introduction and progress check
We are just about up to topic 8,
you should have or be just about to submit
your midterm assignment. We're going to be having fewer videos for
the last few topics, as we want to focus in on
the completion of your project. So, there are no more extensions for
us to show you. Hopefully, you will have one or
two extensions working by the end of this topic that you are happy with, but
maybe still require some refinement. Also having completed the midterm. You will have a good idea about
what you have left to do, and how you are organizing your time
between now and the deadline. If you are feeling like things
are getting behind, try and focus on a single extension and get it
working before moving on to the next. It can be easy to be overwhelmed and
lose direction. It's a good idea to keep on top of
writing notes about your project, and how its progressed over the weeks. I'll help you with your final report. Also, keep a hold of any diagrams or sketches you make,
as these will be helpful too. Although there are fewer videos
in the second half of this topic. Simon will be testing me with
a particularly difficult to bug challenge.
________________


Week 15- 8.201Asynchronous function calls
So far, we've been
skirting around an important feature of JavaScript,
asynchronous functions. In JavaScript, we can
divide function calls into two categories, synchronous
and asynchronous. So far the majority of
function calls we've been calling have
been synchronous. Let's look at a simple example. In a block of code
in our draw loop, each line of code runs in order. Each time we call a synchronous function,
for example ellipse, our draw code pauses whilst the internal code of the
ellipse function is executed. You probably won't have
considered this before, as the functions in the P5
library are black boxes to us, we don't know anything about
what happens inside of them. Now, once the ellipse
function has completed, our draw code resumes, that each line of code where a synchronous function is
called, this will happen. On the other hand some
functions are asynchronous. One example is billowed
sound function. Let's look at what
happens when it is called in the
preload function. Each line of synchronous
code is executed in turn. But when we call the
load sound function, something different happens. The preload function
continues executing at the same time as the load
sound function is executing. Now, you've probably used billowed sound function already, and have been blissfully
unaware that it is an asynchronous function code. For the main part, this
won't cause any problems. But let me give you an
example of where it will. So I've got a code
example here which you can download from
this video as well. In this, you can see that I'm loading a sound in
the preload function. Then, I have made a global
variable code duration, and I'm trying to
get the duration of the sample that I've loaded. So you'll see this is
example of where in this asynchronous function call can cause a problem in my code. So if I run this, you'll see it's
loading now and it shows a sample duration of zero. But I can play the
track. No problem. So it must have a
duration, and in fact, if I open the console,
oops I'll stop that again. I type sample, and
we look down here, we can see that there's
definitely an audio buffer and it definitely has a length there. So what is going on? Well, if I look at the code, this is an asynchronous
function called service. The code here is going
to carry on running, even though we're
loading a sound. So the sound will
still be loading when I make this call to sample duration and so
it won't have been set. That's why we've got a zero there because this function hadn't
yet finished doing its work. So a really simple walk
around that I could think of, would just be to say let's set duration when we press a key
to play the sound. So I could put here duration
equals sample.duration. Now, once I've led you to code, you can see still it says duration zero but
when I press the key, play the sound, it comes
up with the duration. I think that's perhaps in
seconds of the sample. Now, obviously this isn't a really satisfactory solution and we'll be looking at a much better solution in
the next video. Now, you might be thinking why go to the bother of having
asynchronous functions? Why not just make the computer wait until each job is done? It would make our lives as
programmers much easier. The answer is that while certain operations such as
loading files are being done, other activities can
usefully be carried out. Ultimately, asynchronous
programming uses a computer's processing power more efficiently which leads to less spinning wheels and
less frustrating software.
________________


Week 15 - 8.202 Using Callbacks
In the last video, we looked at
asynchronous function calls and the problems that can arise from them. In this video, I'm going to show you
a technique to handle asynchronous events. It's called callbacks. Callbacks are functions, which are passed as arguments during
an asynchronous function call. When the asynchronous function
has completed its operations, the callback function is called. Can you predict what order the statements
will be printed to the console in? We start in our setup function. As we call the asynchronous function, we pass a reference to the function
myCallback for the function to use. The asynchronous operation
inside our function takes an unspecified
amount of time to happen. But eventually the callback is
called where our program can execute any code that can only be run once
the asynchronous operation is done. Notice that we're able to do this
using the argument name callback as opposed to the actual
function name myCallback. This means that a sync function
could be reused with many different callback functions pass to it. What about in this situation? There are actually two possible
outcomes in the first scenario. The asynchronous function
takes a longer time. And so the text am I done is printed to
the console before myCallback is called. In the second, the asynchronous
operation takes a shorter time and the callback happens before the setup
function has a chance to print am I done? So with asynchronous function calls, we can't just rely on the events
happening in a given order. Let's return to our
example with load sound. So if you remember in our previous example
that we're looking at in the last video, we had this problem that load sound
is an asynchronous function call. And that setting duration
didn't work there for here because this function had not yet
finished its business, even though this line of
code is printed afterwards. And so we had a workaround,
an unsatisfactory work around solution of setting duration when you
pressed a key to play the sample. So we're going to work on
a better solution now, so I'm going to comment out this code. And if we look at the p5.js Sound Library And we look at the loadSound function. [SOUND] Sorry that doorbell always
plays when we load that sketch. You'll notice in the arguments that
it doesn't just have one argument. It actually has four. And it has these arguments
that are called callbacks. And so what we can do is we can
create some functions to deal with different events that
happen with loud sound. So the first one I'm going to do
is do one called function success. And I will just put in here in this second argument space I'll put success. So that will point to this function. So now if the sample is loaded
successfully this code here will run. So we should actually put something there. I'm just going to do for
a moment console.log(success). And let's also put the sample.duration. So if it successfully loaded, then we should be able to
obtain the correct duration. So let's try this out. And if I open the console,
you can see that it says here success for
free 6 so this works. Okay, we'll just stop that from running. So we can now get to a proper solution. So all we have to do is we
take this line of code. And we put it in the success function
instead and maybe we also want to take the isReady part of that code,
and I'll also put it there as well. So we won't set the isReady variable
until the samples actually loaded. So let's try that out. I'll run the code again. And there we go. We now see the correct
duration up at the top. Okay, so you'll notice there
were some other ones as well. There was an error callback. So let's make another
function called error. And again I can just pop this in like so. And to start with I might
just console.log(error). Okay, let's load the file. So of course,
normally there isn't an error. So I'm going to have to do
something to make this not work. I tell you what I'll do is
I'll take the V off the end so that the file name is incorrect. Let's see what happens. Okay, so loading is still going but you'll notice I've now
printed to the console error. So this is quite good. Imagine in some kind of app when you
handle an error like this, you know, the program here is stuck, but
we could do something to alert the user. So in this case, what I'm going to do is
I'm going to use the command alerts which opens up an alert box in the in
the browser and you'll see how this works. So I'll just put error here. And you can see now when I try and
load it I get this alert box so I know there's an error. Okay, and so it says alert error, but we actually can find out what
type of error we've got. Now this bit isn't actually
in the documentation but it's very standard behavior for
an error callback. But if I put an argument in here and
I can call it whatever I want. I'll call it for error. That will actually be a string of text
that tells me what's going wrong in the program. So I could add this to my alerts and
now when I load my file, if I try again, it will say error,
load sound unable to load the assets. And so I can see the nature of
the problem and that's really useful. Okay, so I'm going to fix this again and you'll see now that that alert box
shouldn't come up if I refresh the page. There we go. I'm going to add one more call back
because it's here while loading. So this one is has a slightly
different behavior. It gets called over and over again. So I'm going to put that one
in here function we'll call it whileLoading These, by the way,
could called anything that you want. They don't have to be called these
names as long as the name for the relevant function goes
in the right argument. And let's just start by
doing a console.log and I'll just put loading and
you'll see how many times it runs whilst we load the file,
so if I run that again. So you see it's run 25 times
whilst we were loaded and what this also does is it
has an argument called prog. So this works very similar to
this one apart from this one is a number saying how
far it's progressed, so let's print that to the console and
see what we get. So I'll refresh this, and
you can see that number starts at zero and gradually goes towards one
when it's nearly complete. So we could perhaps use that to
draw some text to the screen or to tell the user somehow for the file was
loading and it gives us a progress bar. So those are the three
callbacks from low sound. Let's look at a more
practical example now, so instead of loading a long track like
this I want you to imagine that we're making a game and that this
game has a sound for a race starting. So I found this sound on
the website Freesound.org. If you haven't used this one before
especially if you're looking for things like game sounds,
I really recommend it. They're all
Creative Commons-licensed sounds and they're free to download and use,
so I'm going to download this one. So I've got my downloaded file now and
the next thing to do is to put it into the right
place to be loaded by my app, so I'm going to go to the assets
folder and I'll pop this file here. Now, it's got a quite
long cumbersome name, so I'm going to rename it and
I'll just call it ReadySteadyGo. Let's take a listen to this and hear what it sounds like [SOUND],
so that's our race sound. Now you might notice one thing is that
it's got a lot of time at the end of a file and I want to trim this time off. So I'm going to use an app that's
free to download called Audacity, so if you Google Audacity,
you're going to find that app and it will work on any platform, so
I'm going to open this file with Audacity. And you can see that there's this
long bit of silence at the end and I just want this file to end exactly
at the end without any silence, so I do that and
I'm going to save it again. There we go. All right, and I will now just
replace that one in my folder, and let's load the file here so let's put ReadySteadyGo and we can just test our program. [SOUND] So
we can see also the file is looping, so we need to change that
part of the functionality. So I'm going to just put play instead
of loop and that should be fine. [SOUND] Let's try that again. [SOUND] Okay, so that's much better. Now, what I want to happen is I want, as the file ends, for
us to enter race mode, okay? So what I'm going to do is I'm
going to add a variable and I'm going to make it called isRacing, and isRacing will be forced to start off with. And if isRacing is false,
we will do the background black. Let's do it this way. If not isRacing background is at zero. Otherwise, We will make the background, Some kind of green for go. Maybe make that 200. Okay, so at the moment if I run
this [SOUND] the background stays b lack because we
haven't set isRacing to true. Now, we need to find a way of checking
when that sound file has finished playing and
there's a really good method for this. If we go back to the P5 Sound Library and look at the methods of sound file. There's one called onended and
if I look at onended it's a function where it has as its
single argument a callback and that callback will be run when the file
has ended playing, so I can just do this. I could define this. Let's see. Well, it would be best in the success
function so I could go sample.onended, and I'm going to use a different
version of a callback this time. I think I'll do what's called
an anonymous one, which is when you just create the function inside
the brackets without giving it a name. So sampled.onended and
I put the function in there, and in there I want to set the global
variable isRacing to true. So let's try see what happens in our code,
so we're ready. I'm going to start the race [SOUND], and there you can see as
the file ended playing the screen went green
because we went to isRacing. Okay, there's a slightly more
sophisticated version of this. I'm going to show you that one now,
so onended is one method, but another one which is a little
bit more flexible is called addCue. And if you look at addCue,
you can put in the time in seconds and then you can put the callback and you can even put arguments to
provide the callback function. So in this example they've given, they've
made a function called changetext and I'm going to do something
very similar here. So I'm going to make a function,
and it's going to be called setText, and
we'll put in an argument for that. Now, at the moment we don't we don't have any variables for our screen text, so I'm going to create a variable for that, so var screentext and in setup I'll make screen text
equal to an empty string. And if the sample is playing,
I will go text, we'll draw our screen text to the screen, width divided by 2, height divided by 2. Okay, so
let's say that when we press the button to start playing the sample screen text, should be equal to we'll do one,
two, three, go. I think that's going to be clear. So screen text should be one here, and let's just try that much out. So, I'm going to press the key. [SOUND] So we want to get the two,
three and go. So in order to add these cues,
what I'm going to do is first of all, let's just get this setText
value function complete. So, we'll put screen text equals val, that's all we need to do here and
I'm just going to add the cues. So, instead of doing sample on ended, we'll get rid of that,
we'll go sample.addCue. And we put in the time so we'll just take a guess at the moment. So I'm just going to spread them
out by half a second at a time. So there, setText at 2, I will need to make that a string. So that will be the string to change and
then I'll add another cue. Let's say at one second and
that will be 3. And then finally,
we'll add another cue at 1.5 seconds, and that one will be go
with an exclamation mark. Okay, let's see how that works. [SOUND] Actually, not bad. I thought it was going to be
slightly worse, but that's pretty, pretty close already. But one thing that's not happening
anymore is when it says go, we really want the screen to go green. So I could change
the setText function now, I could say if val == Go, we could set is racing to true. Let's try that. [SOUND] Great, now these sounds
slightly off and we can actually get them better because we could
put in really precise timings. And what I'm actually going to do
is just use Audacity to do that. So I'm going to look back at the file and we're going to just work out exactly
the second, so it starts at 0 seconds. The next one,
looks like to me it's not 0.65 seconds. So I'm going to go back here, and so the
same not 0.5, I'm going to say not 0.65. The next one is actually at 1.2, I would say 1.27 seconds. So, 1.27 seconds. And the last long one is
pretty much 1.9 seconds. So, this should make a much more accurate
response for our starting signal. Let's try it out. [SOUND] So now,
you can see that's really closely synced. Okay, so
that's showing you how to do cues and on ended and
use callback functions with sound. You might want to have a think about how
you could use that in your own audio visualizer app.
________________


Week 16 - 8.302 Progress log (assessed)
As your project progresses it is helpful to keep a log of what you have achieved and what you are planning to do next. Not only will this help to keep your project on track but it will allow us to see how you have approached your project and tackled a larger application.
In the second half of each topic you will be need to complete a log. Make sure you use the following template.
Rich text format:
Microsoft word docx format:
In your log you will need to include…
* Your project title and the current topic.
* What progress have you made this topic?
* What problems have you faced and were you able to solve them?
* What are you planning to do over the next few weeks?
* Are you on target to successfully complete your project?
* If you aren’t on target how will you address the issue?
You will need to compile and submit all your logs at the end of the project. So make sure you keep them safe on your computer. When you have completed all the logs, convert them to a pdf for submission.
Introduction to Programming II Project Log
What progress have you made this topic? 
What problems have you faced and were you able to solve them?
What are you planning to do over the next few weeks?
Are you on target to successfully complete your project? If you aren’t on target, how will you address the issue?
________________


Week 16 - 8.401 Breakpoints and stepping
We're going to take a look at another debugging technique and another feature of the console that we haven't shown here. Now these are some things
that you might have already worked out for yourself, but let's spend a
minute to go over them. So I've got a simple sketch here. There's actually no
real bugs in here, it's just a little
bit convoluted. We got a few functions
calling each other but it's here to illustrate some of these techniques which is to use our breakpoints
to actually step through our code line by line and inspect it as we go along. So if I go to the browser here, type simple bit of
code just displaying a box and some text. We've got a few
functions in here. So if I go inspect, and if I go to sources and let's put in a break
point or inset up on this code to our second function. So, I'll have to refresh to get it to
do what we want to do, so we refresh that. You'll notice that there's
a series of controls here. Now you've probably used this one which resumes the
execution of the script. So if you click here, it'll run on to the
next bit of code, it will stop the break point. If I pause this again but instead of just starting
up the code again, what I might want
to do is see, well, what happens if I
run one more line? Will that be the point
where I introduce the bug. So we've got a number
of controls here to step over the next piece of code, step into the next function code and step out of the
current function. So we can use these in slightly different
ways and I'll show you each of them in turn. But let's start with
this step into which is just going to move you
onto the next line of code, but it's also going to go into a function and show you
the details that function. So this line here,
second function. If I press step into, it's going to show us what
happens in second function. So I've now got an if statement, and if I press step over
or step into again, sorry, it's going to run
this if statement and it's going to evaluate it and we'll see whether my counter is less than the value of five. So if I run that, yes it is. I mean this would be fairly obvious here that my
counter starts at zero. So I'm now setting my
counter to increase by three and express
step into again, move on to the next line. Now, the step over
function won't follow the path down into that function. But let's do it one more time and let's go
into third function. This is where the step
over is useful because I don't want to know what goes on in JavaScript's push function. I don't care. It's
too complicated. So let's press step over. It doesn't follow that function. It just moves me on to
the next part of my code. But if I did press step into and it's not going to do it with the push function
but it will do it rect. So if I click into rect, I am going to see p5
code not my code. I'm not interested in it. If i did by mistake,
I compress the step out of function button. That'll take me back to
where I was and I can just carry on then
stepping over that. So once we've done that, we will go back to our
previous function. So that was my second function. We're setting a value for string, let's skip over that, move down and we're now out into the first function again. If I want to look into
the details of this, I could press step
into. So let's do that. We're just setting some values here and I can step through. Now, you notice
that the stepping, we'll see each part of a for loop or a
series of a couple of parts as it moves its way
through it, certainly inspect. It'll set a var equal to zero then it will then look
at this test condition. We can now count
stepping through. Then it's going to do
this adding one to y and also inspect the value at whether i
is now equal to 1,000, and then move through into
the next lines of code. So hopefully, you maybe have tried these things already when you find bugs in your programs. This is a really useful way for looking into perhaps
what's going on. So we can see that
there's these values for x and y, and temp. Let's go into this function so I can have a look and see
what's inside them, as well as the global
variables because I'm within the scope
of that function. My debugger is inside the
scope of that function. I can also of course,
still look at my global variable steps, so my counter. So I hope you find
these techniques useful and they make your bugs
moving a little bit quicker.
________________


Week 17 9.101 Testing for stability
Hopefully you will have made some
solid progress on your project and are getting absorbed into your code. I'm going to take a few minutes to
introduce you to some of the fundamental ideas around software testing. As ever with this module, this is a short
diversion to help you think about the issues and to consider how effectively
you have implemented your application and to maybe apply some simple
testing during your project. However, if you enjoy these topics there
is a wealth of information you can find out from online sources and
books that will go into much more detail. In this video and a companion video on user testing in the
next topic we'll take a brief overview. We aren't expecting systematic
testing in your projects. But we thought it important
to introduce these topics. And hopefully they will
help you to validate that your program works successfully. In the mark scheme, you will have seen
that we are looking for stability and usability of your application. You might find taking a more formal
approach useful in answering part of the scheme. Before we get into formal testing,
let's take a minute to think about how it diverges from
a topic we have already covered. We have spent a lot of our time on
this module talking about debugging. It's an incredibly important skill and helps to fix any syntax bugs as well
as runtime errors you might encounter. As our programs have grown in size, we will encounter more complex
interactions between our code. Maybe things we didn't see while debugging
because not everything had been written and we were only testing small
parts of the code at a time. Testing is different to debugging,
testing is carried out at a distinct stage during software development,
not necessarily just at the end of coding. Compare this with debugging which is
a continual process while coding. While testing you don't modify
your code between test cases. You will complete all the tests,
then go into a period of correction. Testing also requires a formalized test
plan, whereas debugging is more ad hoc. You may also find that testing is
carried out by automated tools. Whereas debugging is manual,
albeit with the help of Consul and other debugging tools. Testing types are normally divided
along a couple of dimensions. The first of these dimensions
is the level of the test and when in the software development
cycle the tests become applicable. Unit testing examines the smaller
logical units within your program, such as methods,
functions and constructors. Each test is a small piece of code
designed to execute a part of the program and ensure the expected output is
generated with a particular input. It is important to test the unit
with a range of likely valid and invalid input values. You may have heard of unit testing as its
processes have evolved significantly in recent years and it is an important
part of enterprise software development. An additional library is often
employed to help with the tests. A few examples for JavaScript
include Mocha.js, QUnit and Jasmine. This is an example from QUnit. Just before you are ready to run
the program after making changes, you run the test cases to find out if you have
introduced any new errors in your code. Subsequent integration
testing takes these units and tests how they work with one another. In other words,
with a given input to one unit, whose output is fed as input to another,
does it give us the correct final output? There are differing strategies on
how to integrate units together. For example, do you bring them
all together in one go, or start with the lowest level units and
build upon them to a higher level? System testing tests
the completely integrated system. For example, can the user scrub
through the music track, or can the brush size be changed? If you include any of the techniques
from this video into your project, I would encourage you to
look at system testing. And we'll go into more detail in a moment. Normally a system test case will be
derived from formal system requirements. We haven't asked you to do
this in this project, but you still have thought about
the design of your extensions and will be able to critically examine
the functionality of your enhancements. Finally, you may also
encounter acceptance testing. This refers to whether
the software is appropriate for the tasks that it has
been designed to solve. This may include user testing,
we'll talk about that in the next topic. The other approach by which software
testing is traditionally characterized is whether the testing is black or white box. With black box testing, the tester doesn't
know the structure of the underlying code, just what it is supposed to do. In the examples we'll look into,
we'll be using black box testing. Although you know the structure of your
code, it's a bit of an easier start point and better for
the scope of the time you have available. White box testing, which is sometimes
called clear box, focuses on the structure of the code and attempts to
iterate over the logical path through it. You have to be selective though. You can't possibly take all the paths
through your application as a very large number is quickly generated when you start
to have nested conditionals and loops. So you have to select
the best cases to evaluate. For example, around the highest and lowest
possible acceptable values as input. In practice, the distinction between white
and black box testing is quite blurred. In fact a third way,
called gray box testing, is often employed that seeks to make
best use of the two techniques. However, each of the test
levels from earlier can be applied using black or white box testing. Although in practice, unit and integration testing are more likely to
be conducted using white box techniques. And system and
acceptance using black box techniques. Let's work through an example of a test
case for one of our applications and see how we can put black box
system testing into practice. Let's take a look at this in detail,
this particular example. So I have here an enhanced version
of the drawing app, which the only variation from the template is that
I can change the width of the pencil. So if I make that 20 pixels,
we can draw nice fat lines and it will allow me to go from 1 to 50. So I've developed a series of tests for examining whether that tool
works the way that I want it to. So I've actually managed to pull out from
here five different scenarios that I want to evaluate. So different test cases all around
just this little piece of interaction. So I've got here, the first thing that I want to test
is that the default is 2 pixels. So that's set when the the tool
is initially chosen, when it's first loaded up. And I've got a series of steps
here that I need to follow. And I need to do that accurately and correctly to make sure
the test is done correctly. I've got an expected output, which is
the line of 2 pixels drawn to the canvas. And the edit field contains a 2, so
that's what I want it to happen, that's how I want the application
to perform, sorry. And then I've got a couple of boxes
to fill in as I complete my testing. So if we go back to the app,
and let's refresh it and let's have a look at this first test case. So I've got to select the freehand tool, verify the selected line width. Draw a line and
visually verify that that's 2 pixels. So if I run my code here,
I've got my drawing tool selected, pencil width is 2, so that was the first
part that needed to be like that. And then if I draw a line, is it 2 pixels? Well, I can't know that for definite but I can make a visual judgment
that says that that is 2 pixels. Now if I was being really fancy
about this, I could save that image, take it into another drawing app,
would zoom right in and make sure that it's two
blocks that have been used. Okay, so that's my first test. So let's just do As expected, Pass or Fail, Pass. Okay, so the next stage, so
the next test is when an end user enters a valid number that the line
is drawn at the correct width. And we got a different
series of test steps. So select the freehand tool,
enter a width of 1, draw a line, visually verify the width of the line, and then
repeat that step for different widths. So we've got 2, 10, 25, 49 and 50. Now, I've selected 1 and 2 and
49 and 50 to be the boundaries. So I don't want to check
every possible value, but I want to see the ends and
make sure that works correctly. And I've got a couple of additional ones
in here to just see what happens with them there. So if we refresh, so we'll start
each test with a refresh of the app. So let's do 1 pixel, So there's a line. 2 pixels, slightly thicker one, and I think it was 10, 25, 49, And then finally 50. So we can see there that everything
is working as it should do, the lines are getting steadily thicker. And although we, again this sort of visual
inspection doesn't tell us everything, but it appears that that's working
as we would expect, correctly. So we can say As expected, and put in a Pass there. Okay, so
let's look at some invalid values. So select the freehand tool, enter a width
of 0, we should get an error message. Repeat this with some other widths,
so we've got minus 1, 0, 51, a, abc, and the @ symbol. So we're using a range of possibles
that we could do that are incorrect. And hopefully maybe we'll see
some some bugs when we do this. Hopefully not, actually,
hopefully there won't be any bugs. So let's refresh, so if we start with 0 we
get our error message, not a valid input. Okay, message could be
a little friendlier. Minus one, not a valid input,
won't let me do that. And then we had,
what else did we have, 51? So 51, again not a valid input. A, doesn't like a, abc, that's not valid. And the last one was the @ sign,
there we go, and again not valid. So we've got the expected error
message for all of them as we wanted. But I would put in a little note here,
I think, to say actually that's
not a very good message. That looks like a bit of a debug message
rather than something that's there to face a user. So we might say in there, So error message displayed, Terminology needs revising to be more user friendly, okay? So we can put in there,
let's put in there, Fail. So we've actually failed
one of our tests and we'd want that to be looked at by
the developer to improve in the future. So when a new tool is selected the line
width is set correctly for that tool. Okay, so this is, we've done some pencil
drawing, we've got a nice thick line. When we then select another tool, we want to make sure that it goes back
to the correct line width for that tool. So if I have a look at my code,
we're refreshed and ready to go. So let's see what
the instructions are here. Change the width to 50 and
draw on the canvas, so we'll do that. So 50, draw a nice fat line on the canvas. Change to the mirror tool and verify visually that the stroke
width when using the mirror tool. So if we do this, Yep,
that works correctly as we want. So As expected, Pass. Okay, last test,
when the pencil tool is reselected, the previous width should be restored. So select the freehand tool, change the
width to 50, change to the mirror tool. And then change back to
the freehand tool and verify that we still
have this width of 50. So let's refresh, Let's set this to 50. We're going to select the mirror tool,
want to register a little bit of drawing. So as happened before, it goes back
to the width for the mirror tool. If we reselect the pencil, it appears as 50 in the the edit box and
we get our line of 50. So that's correct, and that's a Pass. Now you can see by going
through this process that some of the things that maybe you hadn't
have thought of actually come to the fore. So things like what's going to happen
when I change between these tools? How do I want it to behave? Do I want the width of 50 to
persist to the mirror tool, or do I want it to revert
back to something else? When I open the pencil tool again,
do I want it to stay with what it was previously, or do I want it to
revert back to the default? So these are all little decisions that you
can make while you're building your app. And not only does the testing
help you to find errors and bugs, it also helps you to set up consistent
behavior across your application. As well as making sure that your messages
are accurate and user-friendly as well. So with your applications, you can maybe start to build
up a few test cases like this. Maybe areas where you're worried
about the functionality, making sure it's consistent, making sure
it works correctly throughout the app. Then this will be a good
technique to follow and also to document that
as part of your report.
________________


Week 17 - 9.103 Testing for stability
Discuss ways in which you might use the system testing techniques in your projects.
* Is there specific functionality in your application that could benefit from this kind of testing?
* How would you test that functionality?
________________


Week 18 - 9.202 Progress log (assessed)
As your project progresses, it is helpful to keep a log of what you have achieved and what you are planning to do next. Not only will this help to keep your project on track but it will allow us to see how you have approached your project and tackled a larger application.
In the second half of each topic you will be need to complete a log. Make sure you use the following template.
________________
Week 18 - 9.301 Beyond Console.log

So far, we've looked at a
number of debugging techniques. We've used console.log
and the console to investigate values
in program flow. We've used a debugger to step through the code line by line. In this video, we're
going to look at some further debugging
techniques using the console fervor and also
using Chrome's profiler. So I've got a code
example here to demonstrate this and you can download it too
from the platform. If you run the code, you'll see that it's
a particle system, we get lots of these particles. The other thing that
you might notice is that as the
particles multiply, the program starts to
run slower and slower. You'll notice that the frame
rate is really getting very slow and the particles
are barely moving anymore. So we're going to use some debugging techniques to work out why this is happening. I'm going to stop
this from running. Let's have a look at the
code that we have here. So we have particles
which is an array, that's going to hold
our particle objects. You can see that the
particles have a method called update and a
method called draw., and that we traverse the particles array and we call it for each different particle. You can see here this is
where a new particle is being added and I'm going to guess here that these are positions. So a new particle
is being added in a random position on each frame. So here's our particle
constructor function and you can see it has
things like a position, a direction, speed, and so on. So just to remind you, before we go any further I'm
going to use the debugger and step free some
code so that we can understand in detail how
some of this code works. So I'm first of all going to
have a look at getRandomID. So I'm going to run the
code and I'm going to open the console and we go
to sources and sketch. I'm going to scan and find the bits which has
getRandomID and I'm going to click here into this margin to put a break-point forget ID. So if we have a
look at this code, I think I will just try and make it a bit
bigger. There we go. We can see that we start
with an empty string s and then we've got this
other string called Alpha. If you look what's inside there, it's basically just the
alphabet in capitals and lowercase and numbers from 0-9. Then what we're doing
is we're constructing a string by treating Alpha
as if it's an array. So I'm just going
to step through, so I'm going to use this
button here and you'll see here that we've got Alpha. So we've defined that and we're now going
to do our first loop. So here i is at zero and
we're going to select a random character and you can
see that s is now equal to g. If I go again, we've added another character, it so happens that it was also a g. Let's see if we get a
different one this time. Now we get a N. So I could
keep going on like this. So this is how the
step debugger works. I think this function
is pretty easy to understand for you guys. So I might want to just go all the way through until I
can see the final point of s. So I've put a second break-point here and I'm now going to just press this button again and
it's the continue button, and you can see now I get to s. I can see that indeed I've got a random string there of characters which is going
to make my RandomID. If I want to keep seeing what
happens with this RandomID, I could press continue
and I can see. But it was called by the
constructor function of particle and it gave the ID property for the particle that
was being created. So that's a simple function, I want to look a little bit more of a complicated one now. So we're going to look at
accumulate collisions. So I'm going to get rid
of my old break-points here and I'm going
to press continue. Now we've stopped the program running at accumulate collisions. Here you can see
we're going to do a four loop traversing
through the particles array. So we can see that this is
got an underscore before it. The reason for that is that there's already a global
variable called particles, but I haven't used that exactly. What I've done is I've passed through that global variable
in the update function here. So what this is going
to do, this function, is it's going to loop through
all the particles and see if any of the particles are colliding with this
particular one. If they're colliding, it's
going to take the direction of that particle and add it to the direction of this
particle so that it rebounds off of it. If there are multiple
ones colliding, then it will take
all the different directions and add them together so that we get
a combined rebound. So if we work through this, I think I've done something
a bit wrong there. Let me just try and use continue again to get where
I wanted. That's right. So if we go through this, we'll see that the
first thing it's doing is to check whether the particular particle
it's looking at is indeed the same particle. So if you imagine I've got the
list of all the particles, so one of them is actually the current particle
which I'm working with. So I need to exclude that one and that's why we're
using this ID value. So if we look here we might
be able to investigate. I'll just pull this
across a little bit. So we could see that that bit
got skipped because indeed, the ID of this particle is the same as the one that
we're investigating. So that one we're not
going to see a lot. But let's put a breakpoint
there and get to the next one, so I am going to carry on. If we look here, now i has a value of one, so we're looking at the
next particle in the array. We don't seem to be able
to investigate the ID. We can see our current
ID is this string here. But let's see, they shouldn't
now equal each other. So now, we do some calculations and we see whether the two particles are close enough to each other. In this case, it took
particles weren't close enough to each other, and so we didn't do add
anything to the direction. This loop is going to
go on, and on, and on, It's going to go through
every single particle and check until finally it's determined
the direction of that particular particle. So that's how accumulate
collisions works. Now, as I said, this
program gradually slows down as it's running and we get more and
more particles. Something in my code is slowing down the running of the program and
creating a bottleneck, and that can be sometimes
quite tricky to find out. This is where the
profiler comes in. So I'm going to show
you the profiler now. So I'll reopen the console, and we're going to go to this tab here called performance. I would advise just using Chrome for the sake of this demo, but if you're using Firefox
or any other browser, you will find that they
have a similar tab there. So what I'm going
to do is I'm going to make a recording of the program running and
then it's going to give me lots of information
about what has happened. So I can see that
there's a key to start a new recording
together with a page load, so I'm going to do that
so that I start from zero particles and
gradually build up. So we don't have to do too long. I think I've probably got
about enough time there, so I'm going to press stop. So there we can see the profile, I'll just release
this thing there. One of the things
that you can see here is this orange bar. This orange bar is showing
the use of the CPU. So you can see that it starts off with this
big chunk here, this is the page loading, and then this is our
program running. You can see that the
CPU gradually builds up as the number of
particles increases. We can see some other things. The green bar is the number
of frames per second, and you can see that
the frames per second of our animation gradually decreases as our CPU spikes. Then below here, this bar is representing what's
going on in the memory. You can see that although there's lots of changing activity, it's actually quite stable. For the moment, that
isn't of concern to us. So what we're doing here
is we're looking for the bits of code that's really
causing our bottleneck. What is it that uses
up all of that CPU? Maybe we can think about then how to optimize it if
we can identify it. So I can investigate just a
little piece of the code. So I'm going to take a bit once the CPU has gone really high. If we look here, in fact, I'll go take even smaller bits. Let's try taking
even smaller pods. You can see this
diagram here is showing different function calls and some kind of higher
level things as well. So you can see at the top it's got something called a task. We don't really know what
that is, but beneath it, it has got the event
animation for frame fired. So each time this is happening, we've got a new animation frame. Then we have a undefined
function call. But as we look through, we can get more details. So we see here redraw, that something coming from P5
JS that redraws the frame. Now we get to our draw function that's actually our
P5 drawer function that we're familiar with. Then you can see in here we have lots and lots of calls
to particle update. That makes sense because
we have lots of particles, so each one needs to be updated. Then you can see we have the calls to particle
accumulate collisions. I think I saw some
ellipses in there, and then you can see
there are the calls which draw the
ellipses and so on. So this is how our different
function calls are represented here. But there's another view that's really quite useful to us. I'm going to just see if
I can get that for you, you just need to resize
things a little bit. Here, you can see there is summary and there are
these different ones, and I want you to choose
the one that is bottom up. Here, we get a list of
function calls and their audit in the time and the CPU percentage that
they take the system. This gives us an immediate idea of what is using
all of our CPU up. Here you can see that it's the function call
to accumulate positions. At this point in the program, it took 51 percent of our CPU. So that's quite a lot. Now, you might be wondering
well you might say, well particle update took 58
percent, so isn't that more. But don't forget the
particle update has inside it a call to particle
accumulate position. So that is inclusive of that. If you click this
little triangle, you can see what called it, and then you can see what's
called particle updates. So that's why it's
cool bottom-up, it takes the lowest
function in tray, the final end of the
call and then it works its way up in terms of how it
gives you the information. So we've identified
oscillate function, its accumulate positions. I'm just going to show
you something else. This is something to
watch out for when you're using the profiler. Contextual knowledge
is always important. So if I go back to the beginning of where
my program was running, so when there are only a few particles
and we didn't have so much problem with CPU, let's get right to
the very beginning. and see if I can get even
closer to the beginning there. You'll notice now in this
list that accumulate collisions is not the item
that's using the most CPU. If you think about it, this very beginning of
the program there was only one or two particles, and so it wasn't so problematic. We weren't calling it
so much, and therefore, it wasn't causing this problem. So the bottleneck only becomes apparent when we have
lots of particles. So if you imagine you're
running a different program and you're looking for where
your bottleneck is, you have to make sure that you've replicated
the situation where the bottleneck is happening
so that you can detect it. It's not just enough to just start up the programs straight away and record the profile. So let's actually have
a think about why this dysfunction
is running slowly. So I will just refresh this. Good. I might even
close it for a moment. What I'm going to do is
look at this function, look at the code and try and understand what it is
that makes it runs slow. Well, in this function, we're iterating through
every single particle, and then for nearly all
the particles but one, we're checking the distance between the two particles
with this code. Now, about checking that distance involves using a square root. You can't see it, but it uses Pythagoras's theorem to work out the distance between
the two particles. So that square root it takes
quite a lot of CPU to do, and when that builds up, that can cause a problem. So if we think about it, we start with just one particle. So it's not a problem then, we can take one square root, it's not going to slow
our program down. But as the particles increase, we're doing more and
more iterations. Say we have 1,000 particles, we do 1,000 times in this loop, that's already quite a lot. But then, if we look up
here at our draw loop, we notice that we are calling this function for every
single particles. So we're not just
doing 1,000 cycles, we're doing 1,000
times 1,000 cycles, so we're doing a million
cycles for 1,000 particles. So maybe what we might want
to do is we might want to try and work out how many cycles are happening
over different frames. So this is where I'll show you how we could use console.log. So what I'm going to do
is I'm going to make a running total here of
the number of cycles we've done in this function. So I'm going to make a global
variable called numCycles. I'm going to initialize
my global variable to zero at the start
of each draw cycle. So let's do it here. I can go num cycles equals zero. Now, for every loop
that I do here, I'm going to add
one to num cycles. So I go num cycles plus equals 1. So I've got this running
total of the number of times I'm doing this operation
over all the particles. Then the final thing
I'm going to do is I want to console log base
by number of cycles. So I will put it here
console.lognumcycles, and let's run this and
I'll open the console. You can see the number of cycles going up really,
really quickly. Now, it might be a little bit tricky to follow that
stream of information, so we might want to control
it a little bit more. What I want to do in this
case is I just want to print it for the
first 100 frames. So I'm going to go back
and modify my code. So I get just a list
of the number of cycles for the first 100 frames. So I'm going to put here, if frame counts is
less than a 100. So we'll only print this out if frame count is less than a 100. I think what I would
finally like to do is print the number of particles that we have together with that because that's
useful information. So I'm printing off
these two things, the number of particles
and the number of cycles. There we can see we've
got this nice list showing how many cycles we
have for every particle. So what I might want to do now, I'm going to do this just
to show you something, is I'm going to present
this data in a graph and we can just see how the intensity of use of the CPU increases as
our program runs. So I've plotted out all
those values and you can see that by 40 particles, we're almost at 2,000
cycles per frame. But then by the time we get to 80 particles we're
somewhere around 6,000, and by the time we get
to a 100 particles, were doing 10,000
cycles per frame. This growth in the number of function calls could
be described by the formula N squared minus N, where N is the
number of particles. So if we had two particles
we'd have two cycles, but if we had four
particles well, then that's four squared which
is 16 minus 4 which is 12, so we would have 12 cycles. So we tend to call
this, in computing, we would call this in Big
O notation we would say it has a time complexity
of ON squared. So it means that the complexity of our
program in terms of the work it has to do is
currently rising exponentially. Which means that very soon our program will slow down as the number of
particles increases. So one other thing we might be thinking is
we might be wondering how many collisions between particles are actually happening. So the question I
would ask is do we really need to iterate for all these particles in
the way that we are? Could we find a way
to optimize this? So one way of thinking
about this would be let's just test how many collisions
are actually happening. So I'm going to show you
a way to find this out. So we could take a similar approach and we
could do a running total, but what I want to do here
is I actually want to find out how many collisions are happening for just one particle. So I'm going to comment
out my current console.log code and instead what I'll do is I will sum up inside
one of these functions, inside the accumulated
collision function, I will sum up the number
of collisions happening. So I'll go var
numcollisions equals zero and we can see that we call something a collision if the distance is less than 20. So in here, I will add a
collision if it happens. Then finally, I only
want to print this data. If I printed for every particle, I'm going to get
something unreasonable. I just want to print
it for one particle. So I may as well print it
for particle at position I. So I can test for this. I can say if particles zero ID, say that one equals the current ID then that
must be the first particle. So for that first particle, we will console.log
numcollisions. I'm going to use another command here as well because
I only want to see a running just what the current
number of collisions is. I don't want to see a long list. So I'm going to
use another thing. Before I do that, I'm going to do console.clear. Let's run our code and have a look at
how many collisions. Well, this worked a
little bit better when I tried it in Firefox. I think I'll get rid
of the console.clear, because it's quite
unreasonable there. So I'm just going to comment that out and we'll have a look again. So we have mostly zero collisions and occasionally
we have one collision. So that gives us a clue
about how we might optimize this program because we probably don't need to
be checking all 1,000 particles if we're only
getting one or two collisions. I just want to show you one
final bits of profiling. There's another bits of the profiler we can use which
is the memory profiler. So I'm going to run this and have a look at what's going
on with our memory. So here, I could do
a single snapshot, but this one, this
option here allows me to record the memory
usage over time. So I think that that
could be useful. So I'm going to
try this and we'll see if the memory usage
goes up over time. So I have to time this
a little carefully. I will stop out from recording. What we can see here, if I select a section, is you can see the
amounts of memory that's being used and how much memory is being
just used for that section, but also how much memory is
being retained in the system. So here you can
see, for particles, I'm assuming this is
byte so we're using about 108 kilobytes of memory. So it's really not a lot of
memory that's being used. So we can see here we can use this tool in this case
just to establish, but lack of memory is not
the issue in the problem. It's too many CPU cycles. So using these different tools, we've now got a really
good understanding of what the problem
is with our code, but I haven't given
you a solution. Now, looking at the code, you're probably thinking
of potential solutions. So see if you can
have a go at getting the particle generator to be
a little bit more efficient. What approach would you take?
________________


Week 19 - 10.101 Introduction and progress check
It's the final topic
of the module. These are the last
few videos from Edward Deming before we leave you to complete
your projects. By now, you should
have a firm idea of what you still need to accomplish to complete
your project. Maybe you aren't quite at
the finishing touches stage, but you should have all your
extensions planned out, substantial amounts
of coding done, and the plan for
completing the rest. If you are making good progress, you might also want
to think about making use of some of the
testing techniques from the last topic. We don't expect a complete test plan
for your application, but we advise
developing tests for the more complex elements
of your project. In this topic, we'll also
introduce you to some of the principles behind
usability testing, as well as how to ensure your application meets
the needs of its users. Finally, in this topic, you should be thinking about the report that
accompanies your code. It's a short piece of writing. So you will need to be
concise in your answers. We advise you to
draft a report using a word processor or text
editor with spellcheck, so that you produce
detailed and clear writing.
________________


Week 19 - 10.201 Usability testing
Last topic, I discuss some
thoughts on system testing, and ensuring that
your application has implemented the
required functionality, and it works sufficiently
well in all cases. In this video, we're going to turn our attention to
considering whether you have designed your application effectively for the
people who use it, as well as the system it runs on. We'll be discussing
the basic principles of user testing to ensure our app is usable by those that we'll work with it. The techniques in
this video might be useful when completing
your application, and evaluating your work. Software is complex, but
it is nowhere near as complex as the person trying to make sense of
its functionality, terminology, and how
it works in practice. We need to employ a variety
of tests processes to uncover how our application communicates their functionality to users, are all the controls visible, and in their optimum location? Does the app ensure the user does things in the right order? Can the user find the
parts of the app they need without getting in the way of their creative or logical
thought processes? Usability testing can also
raise questions around the effectiveness of
the application in achieving more human
goals for example, does your drawing application enable an artist to draw
the images they want? Does your music app effectively reflecting
the music style? Or does your data visualization
accurately represent your data such that uses can correctly
interpret its meaning. To these ends, usability testing is often structured around a user experiment
where you invite potential users to
use the application, completing set tasks, and providing feedback on
their experiences. Doing this well is
a complex process, and can involve a huge variety of different possibilities for
your applications tests. The techniques I'll show you in this video would be
a good start point, but if you find this
area interesting, there are plenty of resources
you can find online, and in books to get more detail. The object of a successful
user test is to collect data on user's behavior
with your application. You may remember we talked before about qualitative and
quantitative data, both can be harvested
from user testing. With regards to
quantitative data, you may be interested in how long a user takes to perform
tasks with the application? How many errors do they make? How many tasks are they able
to successfully complete? Or a measure of
their satisfaction having completed all the tasks. You need to determine which are the most important aspects for your user test to
collect data about. A common technique for generating more nuanced qualitative data is called the think
aloud protocol, where you ask the user
to talk their way through the interactions
with the application, what are they doing, and any frustrations they might have. You can subsequently analyze
recordings of users, and highlight areas of
the application that need improvement where several
users have had issues. Another qualitative technique,
would be to interview your participants after
they have completed the tasks about their
experiences with the app. A difficult question when
starting a user test, is to determine the number
of users that you need, and who should they be? This question has been asked by HCI researchers since
HCI became a thing. You aren't expecting statistically
valid data collection so the number can be small. There is an old
acceptance, that is, few as five users can uncover most of the usability
issues in an application. However, we now consider this to be a bit of an
oversimplification, as the variety of
applications has mushroomed over the
last couple of decades. For our purposes in this module, are small test of
five would be ideal, but do pay some consideration to who the users are for example, an art student would have a very different experience with the drawing application to a computer scientist
to drawing flowcharts. Think about who you consider
the target audience to be, and ask representative users. It is vital that
usability tests have a structure that you design before conducting
the research. This way, you can ensure consistency between different
users of your application. A good start point is to think about the
functionality of the app, and design a path
through a few tasks that make use of as much of the functionality of
the app as possible. You need to write this out in very clear steps for
users to follow. We want to test the application, and usability problems in the test steps might mass
problems in the app. As well as the process
users go through, think about how you introduce
them to the application, will you demo any of the
functionality first? Will they be using a laptop, or a touch pad, or a desktop
computer with a mouse? These choices will have an impact on how
they use the app, even something as simple
as whether you leave the printed test
steps on the right, or on the left of the
computer can impact the user. Make sure you are consistent with your choices between the users, and write your own script for discussing how to
get a user started. There is lots of data you can
collect from a user test, I have already mentioned
the think-aloud protocol, which you can record and
reflect on issues that users had after the
completion of the tests. Did users have the same problems? Or can you determine which might be more severe than others? Other forms of data collection
might be timing users, and how long it takes
them to complete a task, or counting the number of
errors the user makes. You may want to make notes as the user works through the test, looking for any problems and frustrations
they experienced. Another common technique, is
to get the user to complete a short survey at
the end of the tasks to measure their satisfaction
with the application. There are standardized
surveys you can use, or you can
write your own. For some examples, use the
web link on this slide. When you have
collected your data, you need to analyze
it to determine where improvements can be made
to the application, and make evaluative judgments on how successful
your application is, if you have counted errors, or ask users to think aloud, you could start this process by looking for convergence between users if several have
had the same problems, it's possible that there is an error that needs to be fixed. You might also want to
compare task at times, perhaps, one task users completed more
quickly than another, in which case you may want to think about the structure
of the two tasks, and determine where
the bottleneck in the applications designer is. For the purposes of
this assignment, we aren't expecting you to iterate through the application, testing prototypes, and building multiple versions
with improvements, but we do want you to write
about it in your report. If you have done
some user testing, make sure you write about
what you found out, what could be improved, and how did users respond
to the application. Also, please include in your appendix the
data you collected, notes, timings, or
collected survey responses.
________________


Week 19 - 10.203 Discussion about usability testing
Discuss ways in which you might use the usability testing techniques in your projects.
* Is there specific functionality in your application that could benefit from this kind of testing?
* How would you test that functionality with users?
________________


Week 20-10.301 Writing your report
We have almost reached
the end of the module. So let's take a minute to discuss the contents of
the final submission. Again we are asking
for you to upload your code alongside
several report responses. This time we also
want you to upload your weekly progress logs too. Firstly, a zip file
containing your code. Make sure you don't use
other compression formats. We should be able to
extract your code, open it in brackets, and run the live server
without any other setup. This time around we
are paying most of our attention and the place where you will get most marks, on an assessment of
the code you submit. The precise details are
in the mark scheme, but as a high level overview, you will receive 60
percent of your marks for the implementation
techniques that you have used. This includes the stability
and usability of the code, the complexity and level
of challenge undertaken, effective and correct use of object orientated
programming techniques, arrays, looping,
and conditionals. A further 20 percent of
your mark will be for the quality and style
of your implementation. This will be based on the code consistency,
commenting, and modularity. The final 20 percent is for the responses to the
report questions in the assignment submission. These are similar to those of the midterm but with
different focus, now that you are reaching the completion of your projects. The first report section is a short description of each
extension or modification, you have added to
the application. You should also include how
the extension is structured, and fits into the design of the template as well
as its functionality. This sections work
count is 400 words. Again, we are allowing 10
percent grace over this count, before you would
lose all the marks for quality of writing. In the next section, you should reflect
on the effectiveness of the plan you produced
for the midterm. Did you divide up your
time effectively? Did you encounter any
unforeseen difficulties? This section is up to 250 words. This is followed by
a brief evaluation of your project as a whole. This can include
self-reflection but make sure that isn't the only
evaluative critique you use. For example, you
can briefly discuss any system or usability
testing you carried out. Again, this section is
250 words in length. The final report section
requires you to list any external resources you
have used in your project. Just like the midterm,
this should include anything where you have
copied or adapted code. This is a crucial step as
it helps us to identify, which parts of the code
are your own invention, and which are adapted. Again, there is no word
count for this section. The last part of the
submission is for you to bundle together
your progress logs. We would like this
to be submitted as a single PDF file which combines all the
logs into one file. Best of luck with the last
stages of your project. We look forward to seeing
what you have come up with.
________________


Week 20 - 10.501 Summary of the module
We have now come to the end of the Introduction to
Programming content. You should still be working on your projects for
a few more weeks, but Edward and I have covered all the material you should need to build a great application. Remember that it's
important to stay focused but relaxed as you
approach the deadline. If you're feeling like
it'll never get done, take a step back, regroup, and revisit
your planning. We have come a long way since the beginning
of the first module. We started with the most basic of drawing commands and have
slowly developed our knowledge. You should now be
comfortable with nested looping,
complex conditionals, object oriented programming
with constructive functions, along with arrays, and
other data structures. For those of you that
have never programmed before this course, hopefully, you will now know
the key concepts that will enable you to take on the other programming topics you will encounter in
the rest of your degree, and for those of you
with experience, we hope that revisiting
the basics will have been a useful exercise in cementing
your knowledge of code. Alongside the JavaScript
syntax we have taught, we have also included content on the process and practices
of programming, co-design, debugging, and
the philosophy of code. Thank you all for following
along with us and for taking an active
part in your learning, posting to the forums, and being part of a constructive
community of learners. It's been a very
rewarding experience first to design and
deliver these modules. We wish you the very best of luck with the rest
of your degree. In your future whether code becomes the backbone
of your career or not, we hope that programming is something that you'll
continue to explore. If you decide to take
your final year with us here in London at Goldsmiths, we'll look forward to meeting
you in person. So bye bye. Bye.


________________






________________


Page #: